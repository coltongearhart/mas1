[
  {
    "objectID": "partA-prob.html",
    "href": "partA-prob.html",
    "title": "Probability Models",
    "section": "",
    "text": "This section contains notes for Part A of the syllabus: Probability Models.",
    "crumbs": [
      "Probability Models"
    ]
  },
  {
    "objectID": "placeholder.html",
    "href": "placeholder.html",
    "title": "1  Placeholder",
    "section": "",
    "text": "1.1 Placeholder\nContent",
    "crumbs": [
      "Probability Models",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Placeholder</span>"
    ]
  },
  {
    "objectID": "partB-stats.html",
    "href": "partB-stats.html",
    "title": "Statistics",
    "section": "",
    "text": "This section contains notes for Part B of the syllabus: Statistics.",
    "crumbs": [
      "Statistics"
    ]
  },
  {
    "objectID": "partC-glm.html",
    "href": "partC-glm.html",
    "title": "Extended Linear Models",
    "section": "",
    "text": "This section contains notes for Part C of the syllabus: Extended Linear Models.",
    "crumbs": [
      "Extended Linear Models"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MAS I",
    "section": "",
    "text": "Overview\nThese notes are to prepare for Exam MAS I (modern actuarial statistics I), which covers three topics: probability models, statistics, and extended linear models.\n\n\n\n\n\n\n\n\nQuarto blog publish details\n\n\n\nThis book was created using Quarto and published with Github Pages.\n\n\n\n\n\n\n\n\nGithub repository for code\n\n\n\nYou can find the code to reproduce this project at coltongearhart/mas1.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "isl-1.html",
    "href": "isl-1.html",
    "title": "3  Statistical learning",
    "section": "",
    "text": "3.1 Notes",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "isl-1.html#notes",
    "href": "isl-1.html#notes",
    "title": "3  Statistical learning",
    "section": "",
    "text": "3.1.1 What is statistical learning?\nSuppose that we observe a quantitative response \\(Y\\) and \\(p\\) different predictors, \\(X_1, X_2, \\ldots , X_p\\). We assume that there is some relationship between \\(Y\\) and \\(X = (X_1, X_2, \\ldots, Xp)\\), which can be written in the very general form\n\\[\nY = f(X) + \\epsilon\n\\]\nHere \\(f\\) is some fixed but unknown function of \\(X_1, \\ldots , X_p\\), and \\(\\epsilon\\) is a random error term, which is independent of \\(X\\) and has mean zero. In this formulation, \\(f\\) represents the systematic information that \\(X\\) provides about \\(Y\\).\nIn essence, statistical learning refers to a set of approaches for estimating \\(f\\).\n\n3.1.1.1 Why estimate \\(f\\)?\nThere are two main reasons that we may wish to estimate \\(f\\): prediction and inference.\nPrediction\nIn many situations, a set of inputs \\(X\\) are readily available, but the output \\(Y\\) cannot be easily obtained. In this setting, since the error term averages to zero, we can predict \\(Y\\) using\n\\[\n\\hat{Y} = \\hat{f}(X),\n\\]\nwhere \\(\\hat{f}\\) represents our estimate for \\(f\\) , and \\(\\hat{Y}\\) represents the resulting prediction for \\(Y\\). In this setting, \\(\\hat{f}\\) is often treated as a black box, in the sense that one is not typically concerned with the exact form of \\(\\hat{f}\\), provided that it yields accurate predictions for \\(Y\\).\nThe accuracy of \\(\\hat{Y}\\) as a prediction for \\(Y\\) depends on two quantities, which we will call the reducible error and the irreducible error. In general, \\(\\hat{f}\\) will not be a perfect estimate for \\(f\\), and this inaccuracy will introduce some error. This error is reducible because we can potentially improve the accuracy of \\(\\hat{f}\\) by using the most appropriate statistical learning technique to estimate \\(f\\). However, even if it were possible to form a perfect estimate for \\(f\\), so that our estimated response took the form \\(\\hat{Y} = f(X)\\), our prediction would still have some error in it! This is because \\(Y\\) is also a function of \\(\\epsilon\\), which, by definition, cannot be predicted using \\(X\\). Therefore, variability associated with \\(\\epsilon\\) also affects the accuracy of our predictions. This is known as the irreducible error, because no matter how well we estimate \\(f\\), we cannot reduce the error introduced by \\(\\epsilon\\).\nWhy is the irreducible error larger than zero? The quantity \\(\\epsilon\\) may contain unmeasured variables that are useful in predicting \\(Y\\): since we don’t measure them, \\(f\\) cannot use them for its prediction. The quantity \\(\\epsilon\\) may also contain unmeasurable variation.\nConsider a given estimate \\(\\hat{f}\\) and a set of predictors \\(X\\), which yields the prediction \\(\\hat{Y} = \\hat{f}(X)\\). Assume for a moment that both \\(\\hat{f}\\) and \\(X\\) are fixed, so that the only variability comes from \\(\\epsilon\\). Then, we can say:\n\nwhere \\(E(Y − \\hat{Y})^2\\) represents the average, or expected value, of the squared difference between the predicted and actual value of \\(Y\\), and \\(Var(\\epsilon)\\) represents the variance associated with the error term \\(\\epsilon\\).\nThe focus of this book is on techniques for estimating \\(f\\) with the aim of minimizing the reducible error. It is important to keep in mind that the irreducible error will always provide an upper bound on the accuracy of our prediction for \\(Y\\). This bound is almost always unknown in practice.\nInference\nWe are often interested in understanding the association between \\(Y\\) and \\(X_1, \\ldots , X_p\\). In this situation we wish to estimate \\(f\\), but our goal is not necessarily to make predictions for \\(Y\\). Now \\(\\hat{f}\\) cannot be treated as a black box, because we need to know its exact form. In this setting, one may be interested in answering the following questions:\n\nWhich predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with \\(Y\\). Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application.\nWhat is the relationship between the response and each predictor? Some predictors may have a positive relationship with \\(Y\\), in the sense that larger values of the predictor are associated with larger values of \\(Y\\). Other predictors may have the opposite relationship. Depending on the complexity of \\(f\\), the relationship between the response and a given predictor may also depend on the values of the other predictors.\nCan the relationship between \\(Y\\) and each predictor be adequately summarized using a linear equation, or is the relationship more complicated? Historically, most methods for estimating \\(f\\) have taken a linear form. In some situations, such an assumption is reasonable or even desirable. But often the true relationship is more complicated, in which case a linear model may not provide an accurate representation of the relationship between the input and output variables.\n\n\n\n\n3.1.2 How do we estimate \\(f\\)?\nThroughout this book, we explore many linear and non-linear approaches for estimating \\(f\\). However, these methods generally share certain characteristics. Here is an overview.\nNote we will always assume that we have observed a set of \\(n\\) different data points, called the training data because we will use these observations to train, or teach, our method how to estimate \\(f\\).\nOur goal is to apply a statistical learning method to the training data in order to estimate the unknown function \\(f\\). In other words, we want to find a function \\(\\hat{f}\\) such that \\(Y \\approx \\hat{f}(X)\\) for any observation \\((X,Y)\\). Broadly speaking, most statistical learning methods for this task can be characterized as either parametric or non-parametric. We now briefly discuss these two types of approaches.\nParametric\nParametric methods involve a two-step model-based approach.\nStep 1\n\nFirst, we make an assumption about the functional form, or shape, of \\(f\\). For example, one very simple assumption is that \\(f\\) is linear in \\(X\\):\n\n\\[\nf(X) = \\beta_0 + \\beta_1 X_1 + \\ldots + \\beta_p X_p\n\\]\n\nThis is a linear model. Once we have assumed that \\(f\\) is linear, the problem of estimating \\(f\\) is greatly simplified. Instead of having to estimate an entirely arbitrary \\(p\\)-dimensional function \\(f(X)\\), one only needs to estimate the p+1 coefficients \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\).\n\nStep 2\n\nAfter a model has been selected, we need a procedure that uses the training data to fit or train the model. In the case of the linear model, we need to estimate the parameters \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\).That is,we want to find values of these parameters such that\n\n\\[\nY \\approx \\beta_0 + \\beta_1 X_1 + \\ldots + \\beta_p X_p\n\\]\n\nThe most common approach to fitting the model above is referred to as (ordinary) least squares. However, least squares is one of many possible ways to fit the linear model.\n\nThe model-based approach just described is referred to as parametric; it reduces the problem of estimating \\(f\\) down to one of estimating a set of parameters. Assuming a parametric form for \\(f\\) simplifies the problem of estimating \\(f\\) because it is generally much easier to estimate a set of parameters, such as \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\) in the linear model, than it is to fit an entirely arbitrary function \\(f\\). The potential disadvantage of a parametric approach is that the model we choose will usually not match the true unknown form of \\(f\\). If the chosen model is too far from the true \\(f\\), then our estimate will be poor. We can try to address this problem by choosing flexible models that can fit many different possible functional forms for \\(f\\). But in general, fitting a more flexible model requires estimating a greater number of parameters. These more complex models can lead to a phenomenon known as overfitting the data, which essentially means they follow the errors, or noise, too closely.\nNon-parametric\nNon-parametric methods do not make explicit assumptions about the functional form of \\(f\\). Instead they seek an estimate of \\(f\\) that gets as close to the data points as possible without being too rough or wiggly. Such approaches can have a major advantage over parametric approaches: by avoiding the assumption of a particular functional form for \\(f\\), they have the potential to accurately fit a wider range of possible shapes for \\(f\\).\nAny parametric approach brings with it the possibility that the functional form used to estimate \\(f\\) is very different from the true \\(f\\), in which case the resulting model will not fit the data well. In contrast, non-parametric approaches completely avoid this danger, since essentially no assumption about the form of \\(f\\) is made. But non-parametric approaches do suffer from a major disadvantage: since they do not reduce the problem of estimating \\(f\\) to a small number of parameters, a very large number of observations (far more than is typically needed for a parametric approach) is required in order to obtain an accurate estimate for \\(f\\).\nBe careful of overfitting though, non-parametric methods can fit the data perfectly if complex enough, which causes the fit obtained to not yield accurate estimates of the response on new observations that were not part of the original training data set.\n\n\n3.1.3 The trade-off between prediction accuracy and model interpretability",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "isl-1.html#exercises",
    "href": "isl-1.html#exercises",
    "title": "3  Statistical learning",
    "section": "3.2 Exercises",
    "text": "3.2 Exercises",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "isl-2.html",
    "href": "isl-2.html",
    "title": "3  Statistical learning",
    "section": "",
    "text": "3.1 Notes",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "isl-2.html#notes",
    "href": "isl-2.html#notes",
    "title": "3  Statistical learning",
    "section": "",
    "text": "3.1.1 What is statistical learning?\nSuppose that we observe a quantitative response \\(Y\\) and \\(p\\) different predictors, \\(X_1, X_2, \\ldots , X_p\\). We assume that there is some relationship between \\(Y\\) and \\(X = (X_1, X_2, \\ldots, Xp)\\), which can be written in the very general form\n\\[\nY = f(X) + \\epsilon\n\\]\nHere \\(f\\) is some fixed but unknown function of \\(X_1, \\ldots , X_p\\), and \\(\\epsilon\\) is a random error term, which is independent of \\(X\\) and has mean zero. In this formulation, \\(f\\) represents the systematic information that \\(X\\) provides about \\(Y\\).\nIn essence, statistical learning refers to a set of approaches for estimating \\(f\\).\n\nWhy estimate \\(f\\)?\nThere are two main reasons that we may wish to estimate \\(f\\): prediction and inference.\nPrediction\nIn many situations, a set of inputs \\(X\\) are readily available, but the output \\(Y\\) cannot be easily obtained. In this setting, since the error term averages to zero, we can predict \\(Y\\) using\n\\[\n\\hat{Y} = \\hat{f}(X),\n\\]\nwhere \\(\\hat{f}\\) represents our estimate for \\(f\\) , and \\(\\hat{Y}\\) represents the resulting prediction for \\(Y\\). In this setting, \\(\\hat{f}\\) is often treated as a black box, in the sense that one is not typically concerned with the exact form of \\(\\hat{f}\\), provided that it yields accurate predictions for \\(Y\\).\nThe accuracy of \\(\\hat{Y}\\) as a prediction for \\(Y\\) depends on two quantities, which we will call the reducible error and the irreducible error. In general, \\(\\hat{f}\\) will not be a perfect estimate for \\(f\\), and this inaccuracy will introduce some error. This error is reducible because we can potentially improve the accuracy of \\(\\hat{f}\\) by using the most appropriate statistical learning technique to estimate \\(f\\). However, even if it were possible to form a perfect estimate for \\(f\\), so that our estimated response took the form \\(\\hat{Y} = f(X)\\), our prediction would still have some error in it! This is because \\(Y\\) is also a function of \\(\\epsilon\\), which, by definition, cannot be predicted using \\(X\\). Therefore, variability associated with \\(\\epsilon\\) also affects the accuracy of our predictions. This is known as the irreducible error, because no matter how well we estimate \\(f\\), we cannot reduce the error introduced by \\(\\epsilon\\).\nWhy is the irreducible error larger than zero? The quantity \\(\\epsilon\\) may contain unmeasured variables that are useful in predicting \\(Y\\): since we don’t measure them, \\(f\\) cannot use them for its prediction. The quantity \\(\\epsilon\\) may also contain unmeasurable variation.\nConsider a given estimate \\(\\hat{f}\\) and a set of predictors \\(X\\), which yields the prediction \\(\\hat{Y} = \\hat{f}(X)\\). Assume for a moment that both \\(\\hat{f}\\) and \\(X\\) are fixed, so that the only variability comes from \\(\\epsilon\\). Then, we can say:\n\nwhere \\(E(Y − \\hat{Y})^2\\) represents the average, or expected value, of the squared difference between the predicted and actual value of \\(Y\\), and \\(Var(\\epsilon)\\) represents the variance associated with the error term \\(\\epsilon\\).\nThe focus of this book is on techniques for estimating \\(f\\) with the aim of minimizing the reducible error. It is important to keep in mind that the irreducible error will always provide an upper bound on the accuracy of our prediction for \\(Y\\). This bound is almost always unknown in practice.\nInference\nWe are often interested in understanding the association between \\(Y\\) and \\(X_1, \\ldots , X_p\\). In this situation we wish to estimate \\(f\\), but our goal is not necessarily to make predictions for \\(Y\\). Now \\(\\hat{f}\\) cannot be treated as a black box, because we need to know its exact form. In this setting, one may be interested in answering the following questions:\n\nWhich predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with \\(Y\\). Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application.\nWhat is the relationship between the response and each predictor? Some predictors may have a positive relationship with \\(Y\\), in the sense that larger values of the predictor are associated with larger values of \\(Y\\). Other predictors may have the opposite relationship. Depending on the complexity of \\(f\\), the relationship between the response and a given predictor may also depend on the values of the other predictors.\nCan the relationship between \\(Y\\) and each predictor be adequately summarized using a linear equation, or is the relationship more complicated? Historically, most methods for estimating \\(f\\) have taken a linear form. In some situations, such an assumption is reasonable or even desirable. But often the true relationship is more complicated, in which case a linear model may not provide an accurate representation of the relationship between the input and output variables.\n\n\n\nHow do we estimate \\(f\\)?\nThroughout this book, we explore many linear and non-linear approaches for estimating \\(f\\). However, these methods generally share certain characteristics. Here is an overview.\nNote we will always assume that we have observed a set of \\(n\\) different data points, called the training data because we will use these observations to train, or teach, our method how to estimate \\(f\\).\nOur goal is to apply a statistical learning method to the training data in order to estimate the unknown function \\(f\\). In other words, we want to find a function \\(\\hat{f}\\) such that \\(Y \\approx \\hat{f}(X)\\) for any observation \\((X,Y)\\). Broadly speaking, most statistical learning methods for this task can be characterized as either parametric or non-parametric. We now briefly discuss these two types of approaches.\nParametric\nParametric methods involve a two-step model-based approach.\nStep 1\n\nFirst, we make an assumption about the functional form, or shape, of \\(f\\). For example, one very simple assumption is that \\(f\\) is linear in \\(X\\):\n\n\\[\nf(X) = \\beta_0 + \\beta_1 X_1 + \\ldots + \\beta_p X_p\n\\]\n\nThis is a linear model. Once we have assumed that \\(f\\) is linear, the problem of estimating \\(f\\) is greatly simplified. Instead of having to estimate an entirely arbitrary \\(p\\)-dimensional function \\(f(X)\\), one only needs to estimate the p+1 coefficients \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\).\n\nStep 2\n\nAfter a model has been selected, we need a procedure that uses the training data to fit or train the model. In the case of the linear model, we need to estimate the parameters \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\).That is,we want to find values of these parameters such that\n\n\\[\nY \\approx \\beta_0 + \\beta_1 X_1 + \\ldots + \\beta_p X_p\n\\]\n\nThe most common approach to fitting the model above is referred to as (ordinary) least squares. However, least squares is one of many possible ways to fit the linear model.\n\nThe model-based approach just described is referred to as parametric; it reduces the problem of estimating \\(f\\) down to one of estimating a set of parameters. Assuming a parametric form for \\(f\\) simplifies the problem of estimating \\(f\\) because it is generally much easier to estimate a set of parameters, such as \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\) in the linear model, than it is to fit an entirely arbitrary function \\(f\\). The potential disadvantage of a parametric approach is that the model we choose will usually not match the true unknown form of \\(f\\). If the chosen model is too far from the true \\(f\\), then our estimate will be poor. We can try to address this problem by choosing flexible models that can fit many different possible functional forms for \\(f\\). But in general, fitting a more flexible model requires estimating a greater number of parameters. These more complex models can lead to a phenomenon known as overfitting the data, which essentially means they follow the errors, or noise, too closely.\nNon-parametric\nNon-parametric methods do not make explicit assumptions about the functional form of \\(f\\). Instead they seek an estimate of \\(f\\) that gets as close to the data points as possible without being too rough or wiggly. Such approaches can have a major advantage over parametric approaches: by avoiding the assumption of a particular functional form for \\(f\\), they have the potential to accurately fit a wider range of possible shapes for \\(f\\).\nAny parametric approach brings with it the possibility that the functional form used to estimate \\(f\\) is very different from the true \\(f\\), in which case the resulting model will not fit the data well. In contrast, non-parametric approaches completely avoid this danger, since essentially no assumption about the form of \\(f\\) is made. But non-parametric approaches do suffer from a major disadvantage: since they do not reduce the problem of estimating \\(f\\) to a small number of parameters, a very large number of observations (far more than is typically needed for a parametric approach) is required in order to obtain an accurate estimate for \\(f\\).\nBe careful of overfitting though, non-parametric methods can fit the data perfectly if complex enough, which causes the fit obtained to not yield accurate estimates of the response on new observations that were not part of the original training data set.\n\n\n\nThe trade-off between prediction accuracy and model interpretability\nOf the many methods that we examine in this book, some are less flexible, or more restrictive, in the sense that they can produce just a relatively small range of shapes to estimate \\(f\\). For example, linear regression is a relatively inflexible approach, because it can only generate linear functions (smooth lines / planes). Other methods are considerably more flexible because they can generate a much wider range of possible shapes to estimate \\(f\\).\nOne might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very flexible approach? There are several reasons that we might prefer a more restrictive model. If we are mainly interested in inference, then restrictive models are much more interpretable. For instance, when inference is the goal, the linear model may be a good choice since it will be quite easy to understand the relationship between \\(Y\\) and \\(X_1, X_2, \\ldots, X_p\\). In contrast, very flexible approaches, such as the splines and boosting methods can lead to such complicated estimates of \\(f\\) that it is difficult to understand how any individual predictor is associated with the response.\nHere is an illustration of the trade-off between flexibility and interpretability for some of the methods that we cover in this book.\n\nLeast squares linear regression is relatively inflexible but is quite interpretable. The lasso relies upon the linear model but uses an alternative fitting procedure for estimating the coefficients \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\). The new procedure is more restrictive in estimating the coefficients, and sets a number of them to exactly zero. Hence in this sense the lasso is a less flexible approach than linear regression. It is also more interpretable than linear regression, because in the final model the response variable will only be related to a small subset of the predictors — namely, those with nonzero coefficient estimates.\nGeneralized additive models (GAMs), discussed in Chapter 7, instead extend the linear model to allow for certain non-linear relationships. Consequently, GAMs are more flexible than linear regression. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve. Finally, fully non-linear methods such as bagging, boosting, support vector machines with non-linear kernels, and neural networks (deep learning) are highly flexible approaches that are harder to interpret.\nWe have established that when inference is the goal, there are clear advantages to using simple and relatively inflexible statistical learning methods. In some settings, however, we are only interested in prediction, and the interpretability of the predictive model is simply not of interest; our sole requirement for the algorithm is that it predict accurately (i.e. interpretability is not a concern). In this setting, we might expect that it will be best to use the most flexible model available. Surprisingly, this is not always the case! We will often obtain more accurate predictions using a less flexible method. This phenomenon, which may seem counterintuitive at first glance, has to do with the potential for overfitting in highly flexible methods.\n\n\nSupervised vs unsupervised learning\nMost statistical learning problems fall in to one of two categories: supervised or unsupervised. The examples that we have discussed so far in this chapter all fall into the supervised learning domain. For each observation of the predictor measurement(s) \\(x_i, i = 1, \\ldots , n\\) there is an associated response measurement \\(y_i\\). We wish to fit a model that relates the response to the predictors, with the aim of accurately predicting the response for future observations (prediction) or better understanding the relationship between the response and the predictors (inference). Many classical statistical learning methods such as linear regression and logistic regression, as well as more modern approaches such as GAM, boosting, and support vector machines, operate in the supervised learning domain. The vast majority of this book is devoted to this setting.\nBy contrast, unsupervised learning describes the somewhat more challenging situation in which for every observation \\(i = 1, \\ldots, n\\), we observe a vector of measurements \\(x_i\\) but no associated response \\(y_i\\). It is not possible to fit a linear regression model, since there is no response variable to predict. In this setting, we are in some sense working blind; the situation is referred to as unsupervised because we lack a response variable that can supervise our analysis. What sort of statistical analysis is possible? We can seek to understand the relationships between the variables or between the observations. One statistical learning tool that we may use in this setting is cluster analysis, or clustering. The goal of cluster analysis is to ascertain, on the basis of \\(x_1, \\ldots, x_n\\), whether the observations fall into relatively distinct groups.\n\nHowever, in practice the group memberships are unknown, and the goal is to determine the group to which each observation belongs. A clustering method could not be expected to assign all of the overlapping points to their correct group.\nIn the example above, there are only two variables, and so one can simply visually inspect the scatterplots of the observations in order to identify clusters. However, in practice, we often encounter data sets that contain many more than two variables. In this case, we cannot easily plot the observations. For instance, if there are \\(p\\) variables in our data set, then \\(p(p − 1)/2\\) distinct scatterplots can be made, and visual inspection is simply not a viable way to identify clusters. For this reason, automated clustering methods are important.\nMany problems fall naturally into the supervised or unsupervised learning paradigms. However, sometimes the question of whether an analysis should be considered supervised or unsupervised is less clear-cut. For instance, suppose that we have a set of \\(n\\) observations. For \\(m\\) of the observations, where \\(m &lt; n\\), we have both predictor measurements and a response measurement. For the remaining \\(n − m\\) observations, we have predictor measurements but no response measurement. Such a scenario can arise if the predictors can be measured relatively cheaply but the corresponding responses are much more expensive to collect. We refer to this setting as a semi-supervised learning problem. In this setting, we wish to use a statistical learning method that can incorporate the \\(m\\) observations for which response measurements are available as well as the \\(n − m\\) observations for which they are not. Although this is an interesting topic, it is beyond the scope of this book.\n\n\nRegression vs classification problems\nWe tend to refer to problems with a quantitative response as regression problems, while those involving a qualitative response are often referred to as classification problems. However, the distinction is not always that crisp. Least squares linear regression is used with a quantitative response, whereas logistic regression is typically used with a qualitative (two-class, or binary) response. Thus, despite its name, logistic regression is a classification method. But since it estimates class probabilities, it can be thought of as a regression method as well. Some statistical methods, such as \\(K\\)-nearest neighbors and boosting, can be used in the case of either quantitative or qualitative responses.\nWe tend to select statistical learning methods on the basis of whether the response is quantitative or qualitative; i.e. we might use linear regression when quantitative and logistic regression when qualitative. However, whether the predictors are qualitative or quantitative is generally considered less important. Most of the statistical learning methods discussed in this book can be applied regardless of the predictor variable type, provided that any qualitative predictors are properly coded before the analysis is performed.\n\n\n\n3.1.2 Assessing model accuracy\nOne of the key aims of this book is to introduce the reader to a wide range of statistical learning methods that extend far beyond the standard linear regression approach. Why is it necessary to introduce so many different statistical learning approaches, rather than just a single best method? There is no free lunch in statistics: no one method dominates all others over all possible data sets. On a particular data set, one specific method may work best, but some other method may work better on a similar but different data set. Hence it is an important task to decide for any given set of data which method produces the best results. Selecting the best approach can be one of the most challenging parts of performing statistical learning in practice.\nNow, we discuss some of the most important concepts that arise in selecting a statistical learning procedure for a specific data set.\n\nMeasuring the quality of fit\nIn order to evaluate the performance of a statistical learning method on a given data set, we need some way to measure how well its predictions actually match the observed data. That is, we need to quantify the extent to which the predicted response value for a given observation is close to the true response value for that observation. In the regression setting, the most commonly-used measure is the mean squared error (MSE), given by\n\\[\nMSE = \\frac{1}{n} \\sum_{i = 1}^n (y_i - \\hat{f}(x_i))^2\n\\] The MSE will be small if the predicted responses are very close to the true responses, and will be large if for some of the observations, the predicted and true responses differ substantially.\nThis MSE is computed using the training data that was used to fit the model, and so should more accurately be referred to as the training MSE. But in general, we do not really care how well the method works training on the training data. Rather, we are interested in the accuracy of the predictions that we obtain when we apply our method to previously unseen test data. To state it more mathematically, suppose that we fit our statistical learn- ing method on our training observations \\(\\{(x_1,y_1), (x_2,y_2), \\ldots, (x_n,y_n)\\}\\), and we obtain the estimate \\(\\hat{f}\\). We can then compute \\(\\hat{f}(x_1), \\hat{f}(x_2), \\ldots , \\hat{f}(x_n)\\). If these are approximately equal to \\(y_1, y_2, \\ldots, y_n\\), then the training MSE is small. However, we are really not interested in whether \\(\\hat{f}(x_i) \\approx y_i\\); instead, we want to know whether \\(\\hat{f}(x_0)\\) is approximately equal to \\(y_0\\), where \\((x_0,y_0)\\) is a previously unseen test observation not used to train the statistical learning method. We want to choose the method that gives the lowest test MSE, as opposed to the lowest training MSE. In other words, if we had a large number of test observations, we could compute the average squared prediction error for these test observations \\((x_0,y_0)\\):\n\\[\n\\text{Ave}(y_0 - \\hat{f}(x_0))^2\n\\]\nWe’d like to select the model for which this quantity is as small as possible.\nHow can we go about trying to select a method that minimizes the test MSE? In some settings, we may have a test data set available. We can then simply evaluate the above formula on the test observations, and select the learning method for which the test MSE is smallest. But what if no test observations are available? In that case, one might imagine simply selecting a statistical learning method that minimizes the training MSE. This seems like it might be a sensible approach, since the training MSE and the test MSE appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods specifically estimate coefficients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, but the test MSE is often much larger.\nThe figure below illustrates this concept. In the left-hand panel, we have generated observations from some \\(f(X)\\) with the true \\(f\\) given by the black curve. The orange, blue and green curves illustrate three possible estimates for \\(f\\) obtained using methods with increasing levels of flexibility.\n\nThe blue and green curves were produced using smoothing splines. It is clear that as the level of flexibility increases, the curves fit the observed data more closely. The green curve is the most flexible and matches the data very well; however, we observe that it fits the true \\(f\\) (shown in black) poorly because it is too wiggly.\nOn the right panel, the grey curve displays the average training MSE as a function of flexibility, or more formally the degrees of freedom, for a number of smoothing splines. The degrees of freedom is a quantity that summarizes the flexibility of a curve. A more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve (i.e. more error dfs; a more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve). The training MSE declines monotonically as flexibility increases. In this example the true \\(f\\) is non-linear, and so the orange linear fit is not flexible enough to estimate f well. The green curve has the lowest training MSE of all three methods, since it corresponds to the most flexible of the three curves fit in the left-hand panel.\nIn this example, we know the true function \\(f\\), and so we can also compute the test MSE over a very large test set, as a function of flexibility. (Of course, in general \\(f\\) is unknown, so this will not be possible. The horizontal dashed line indicates \\(\\text{Var}(\\epsilon)\\), the irreducible error, which corresponds to the lowest achievable test MSE among all possible methods. As the flexibility of the statistical learning method increases, we observe a monotone decrease in the training MSE and a U-shape in the test MSE (red line). This is a fundamental property of statistical learning that holds regardless of the particular data set at hand and regardless of the statistical method being used. As model flexibility increases, training MSE will decrease, but the test MSE may not. When a given method yields a small training MSE but a large test MSE, we are said to be overfitting the data. This happens because our statistical learning procedure is working too hard to find patterns in the training data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function \\(f\\). When we overfit the training data, the test MSE will be very large because the supposed patterns that the method found in the training data simply don’t exist in the test data. Note that regardless of whether or not overfitting has occurred, we almost always expect the training MSE to be smaller than the test MSE because most statistical learning methods either directly or indirectly seek to minimize the training MSE. Overfitting refers specifically to the case in which a less flexible model would have yielded a smaller test MSE.\nHere is another example that displays the same patterns. However, because the truth is close to linear, the test MSE only decreases slightly before increasing again, so that the orange least squares fit is substantially better than the highly flexible green curve.\n\nFinally, here is another example in which \\(f\\) is highly non-linear. Now there is a rapid decrease in both curves before the test MSE starts to increase slowly.\n\nIn practice, one can usually compute the training MSE with relative ease, but estimating test MSE is considerably more difficult because usually no test data are available. As the previous three examples illustrate, the flexibility level corresponding to the model with the minimal test MSE can vary considerably among data sets. Throughout this book, we discuss a variety of approaches that can be used in practice to estimate this minimum point. One important method is cross-validation, which is a method for estimating test MSE using the training data.\n\n\nThe bias-variance trade-off\nThe U-shape observed in the test MSE curves turns out to be the result of two competing properties of statistical learning methods. It is possible to show that the expected test MSE, for a given value \\(x_0\\), can always be decomposed into the sum of three fundamental quantities: the variance of \\(\\hat{f}(x_0)\\), the squared bias of \\(f(x_0)\\) and the variance of the error terms \\(\\epsilon\\). That is,\n\\[\nE\\big(y_o - \\hat{f}(x_0)\\big)^2 = \\text{Var}(\\hat{f}(x_0)) + [\\text{Bias}(\\hat{f}(x_0))]^2 + \\text{Var}(\\epsilon)\n\\]\n\nHere, the notation \\(E\\big(y_o - \\hat{f}(x_0)\\big)^2\\) defines the expected test MSE at \\(x_0\\), and refers to the average test MSE that we would obtain if we repeatedly estimated \\(f\\) using a large number of training sets, and tested each at \\(x_0\\). The overall expected test MSE can be computed by averaging \\(E\\big(y_o - \\hat{f}(x_0)\\big)^2\\) over all possible values of \\(x_0\\) in the test set.\nThis equation tells us that in order to minimize the expected test error, we need to select a statistical learning method that simultaneously achieves low variance and low bias. Note that variance is inherently a nonnegative quantity, and squared bias is also nonnegative. Hence, we see that the expected test MSE can never lie below \\(\\text{Var}(\\epsilon)\\), the irreducible error.\nWhat do we mean by the variance and bias of a statistical learning method? Variance refers to the amount by which \\(\\hat{f}\\) would change if we estimated it using a different training data set. Since the training data are used to fit the statistical learning method, different training data sets will result in a different \\(\\hat{f}\\). But ideally the estimate for f should not vary too much between training sets. However, if a method has high variance then small changes in the training data can result in large changes in \\(\\hat{f}\\). In general, more flexible statistical methods have higher variance.\nOn the other hand, bias refers to the error that is introduced by approximating a real-life problem, which may be extremely complicated, by a much simpler model. Generally, more flexible methods result in less bias.\nAs a general rule, as we use more flexible methods, the variance will increase and the bias will decrease. The relative rate of change of these two quantities determines whether the test MSE increases or decreases. As we increase the flexibility of a class of methods, the bias tends to initially decrease faster than the variance increases. Consequently, the expected test MSE declines. However, at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. When this happens the test MSE increases. For the previous examples, here are the variance, bias curves:\n\nThis shows that variance is an increasing function of flexibility, and bias is a decreasing function. The goal is to find the balance point. This trade-off is one of the most important recurring themes in this book.\nIn a real-life situation in which \\(f\\) is unobserved, it is generally not possible to explicitly compute the test MSE, bias, or variance for a statistical learning method. Nevertheless, one should always keep the bias-variance trade-off in mind. In this book we explore methods that are extremely flexible and hence can essentially eliminate bias. However, this does not guarantee that they will outperform a much simpler method such as linear regression. To take an extreme example, suppose that the true \\(f\\) is linear. In this situation linear regression will have no bias, making it very hard for a more flexible method to compete. In contrast, if the true \\(f\\) is highly non-linear and we have an ample number of training observations, then we may do better using a highly flexible approach. Later, we discuss cross-validation, which is a way to estimate the test MSE using the training data.\n\n\nThe classification setting\nThus far, our discussion of model accuracy has been focused on the regression setting. But many of the concepts that we have encountered, such as the bias-variance trade-off, transfer over to the classification setting with only some modifications due to the fact that \\(y_i\\) is no longer quantitative. Suppose that we seek to estimate \\(f\\) on the basis of training observations \\(\\{(x_1,y_1), \\ldots, (x_n,y_n)\\}\\), where now \\(y_1, \\ldots , y_n\\) are qualitative. The most common approach for quantifying the accuracy of our estimate \\(\\hat{f}\\) is the training error rate, the proportion of mistakes that are made if we apply our estimate \\(\\hat{f}\\) to the training observations:\n\\[\n\\frac{1}{n} \\sum_{i = 1}^n I(y_i \\ne \\hat{y}_i)\n\\]\nHere \\(\\hat{y}_i\\) is the predicted class label for the \\(i\\)th observation using \\(\\hat{f}\\). And \\(I(y_i \\ne \\hat{y}_i))\\) is an indicator variable that equals 1 if \\(y_i \\ne \\hat{y}_i\\) and zero if \\(y_i = \\hat{y}_i\\) (i.e. indicator if wrong). Thus, the above equation computes the fraction of incorrect classifications.\nThe test error rate associated with a set of test observations of the form \\((x_0, y_0)\\) is given by\n\\[\n\\text{Ave}(I(y_0 \\ne \\hat{y}_0))\n\\]\nA good classifier is one for which the test error is smallest.\nThe Bayes classifier\nIt is possible to show (though the proof is outside of the scope of this book) that the test error rate given in is minimized, on average, by a very simple classifier that assigns each observation to the most likely class, given its predictor values. In other words, we should simply assign a test observation with predictor vector \\(x_0\\) to the class \\(j\\) for which\n\\[\n\\text{Pr}(Y = j \\mid X = x_0)\n\\]\nis the largest. Note that the above formula is a conditional probability: it is the probability that \\(Y = j\\), given the observed predictor vector \\(x_0\\). This very simple classifier is called the Bayes classifier. In a two-class problem where there are only two possible response values, say class 1 or class 2, the Bayes classifier corresponds to predicting class one if \\(\\text{Pr}(Y = j \\mid X = x_0) &gt; 0.5\\), and class two otherwise.\nHere is an example:\n\nFor each value of \\(X_1\\) and \\(X_2\\), there is a different probability of the response being orange or blue. Since this is simulated data, we know how the data were generated and we can calculate the conditional probabilities for each value of \\(X_1\\) and \\(X_2\\). The purple dashed line represents the points where the probability is exactly 50%. This is called the Bayes decision boundary.\nThe Bayes classifier produces the lowest possible test error rate, called the Bayes error rate. Since the Bayes classifier will always choose the class for which the above formula is largest, the error rate will be \\(1 − \\text{max}_j \\, \\text{Pr}(Y = j \\mid X = x_0)\\) at \\(X = x_0\\). In general, the overall Bayes error rate is given by\n\\[\n1 - E\\big(\\underset{j}{\\text{max}} \\, \\text{Pr}(Y = j \\mid X)\\big)\n\\]\nwhere the expectation averages the probability over all possible values of \\(X\\). The Bayes error rate is analogous to the irreducible error, discussed earlier.\n\n\\(K\\)-Nearest neighbors\nIn theory we would always like to predict qualitative responses using the Bayes classifier. But for real data, we do not know the conditional distribution of \\(Y\\) given \\(X\\), and so computing the Bayes classifier is impossible. Therefore, the Bayes classifier serves as an unattainable gold standard against which to compare other methods.\n\nMany approaches attempt to estimate the conditional distribution of \\(Y\\) given \\(X\\), and then classify a given observation to the class with highest estimated probability. One such method is the K-nearest neighbors (KNN) classifier. Given a positive integer \\(K\\) and a test observation \\(x_0\\), the KNN classifier first identifies the \\(K\\) points in the training data that are closest to \\(x_0\\), represented by \\(\\cal{N}_0\\). It then estimates the conditional probability for class \\(j\\) as the fraction of points in \\(\\cal{N}_0\\) whose response values equal \\(j\\):\n\\[\n\\text{Pr}(Y = j \\mid X = x_0) = \\frac{1}{K}\\sum_{i \\in \\cal{N}_0} I(y_i = j)\n\\]\nFinally, KNN classifies the test observation \\(x_0\\) to the class with the largest probability from the equation above.\nHere is an example of the KNN approach:\n\nDespite the fact that it is a very simple approach, KNN can often produce classifiers that are surprisingly close to the optimal Bayes classifier. Note that even though the true distribution is not known by the KNN classifier, the KNN decision boundary is very close to that of the Bayes classifier.\n\nHowever, the choice of \\(K\\) has a drastic effect on the KNN classifier obtained.\n\nWhen \\(K = 1\\), the decision boundary is overly flexible and finds patterns in the data that don’t correspond to the Bayes decision boundary. This corresponds to a classifier that has low bias but very high variance. As \\(K\\) grows, the method becomes less flexible and produces a decision boundary that is close to linear. This corresponds to a low-variance but high-bias classifier.\nJust as in the regression setting, there is not a strong relationship between the training error rate and the test error rate. With \\(K = 1\\), the KNN training error rate is 0, but the test error rate may be quite high. In general, as we use more flexible classification methods, the training error rate will decline but the test error rate may not.\n\nAs \\(1/K\\) increases, the method becomes more flexible. As in the regression setting, the training error rate consistently declines as the flexibility increases. However, the test error exhibits a characteristic U-shape, declining at first (with a minimum at approximately \\(K = 10\\)) before increasing again when the method becomes excessively flexible and overfits.\nIn both the regression and classification settings, choosing the correct level of flexibility is critical to the success of any statistical learning method. The bias-variance trade-off, and the resulting U-shape in the test error, can make this a difficult task.",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "isl-2.html#exercises",
    "href": "isl-2.html#exercises",
    "title": "3  Statistical learning",
    "section": "3.3 Exercises",
    "text": "3.3 Exercises\n\n3.3.1 Conceptual\n\nQuestion 1\n\nFor each of parts (a) through (d), indicate whether we would generally expect the performance of a flexible statistical learning method to be better or worse than an inflexible method. Justify your answer.\n\nThe sample size \\(n\\) is extremely large, and the number of predictors \\(p\\) is small.\n\n\nA flexible model will perform better than an inflexible model because there are ample degrees of freedom to estimate many parameters and still have many leftover for error df.\n\n\nThe number of predictors \\(p\\) is extremely large, and the number of observations \\(n\\) is small.\n\n\nAn inflexible will be better because there is a high chance of some predictors being randomly associated.\n\n\nThe relationship between the predictors and response is highly non-linear.\n\n\nA flexible model will perform better because it can pick up on the non-linear trends better.\n\n\nThe variance of the error terms, i.e. \\(\\sigma^2 = \\text{Var}(\\epsilon)\\), is extremely high.\n\n\nInflexible model will be better because the flexible model will pick up on the noise a lot better even though it is not related to the relationship to the \\(X\\)s.\n\n\nQuestion 2\n\nExplain whether each scenario is a classification or regression problem, and indicate whether we are most interested in inference or prediction. Finally, provide \\(n\\) and \\(p\\).\n\n\n\nWe collect a set of data on the top 500 firms in the US. For each firm we record profit, number of employees, industry and the CEO salary. We are interested in understanding which factors affect CEO salary.\n\n\nRegression; inference; \\(n = 500, p = 3\\)\n\n\nWe are considering launching a new product and wish to know whether it will be a success or a failure. We collect data on 20 similar products that were previously launched. For each product we have recorded whether it was a success or failure, price charged for the product, marketing budget, competition price, and ten other variables.\n\n\nClassification; prediction; \\(n = 20, p = 13\\)\n\n\nWe are interested in predicting the % change in the USD/Euro exchange rate in relation to the weekly changes in the world stock markets. Hence we collect weekly data for all of 2012. For each week we record the % change in the USD/Euro, the % change in the US market, the % change in the British market, and the % change in the German market.\n\n\nRegression; prediction; \\(n = 52, p = 3\\).\n\n\nQuestion 3\n\nWe now revisit the bias-variance decomposition.\n\n\n\nProvide a sketch of typical (squared) bias, variance, training error, test error, and Bayes (or irreducible) error curves, on a single plot, as we go from less flexible statistical learning methods towards more flexible approaches. The x-axis should represent the amount of flexibility in the method, and the y-axis should represent the values for each curve. There should be five curves. Make sure to label each one.\n\n\n\n\n\nExplain why each of the five curves has the shape displayed in part (a).\n\n\n\nBias: Decreases until leveling off as flexibility increases (nears zero)\nVariance: Increases faster as flexibility increases\nBayes (irreducible error): Constant, unrelated to flexibility (\\(X\\))\nTraining error rate: Decrease monotonically as flexibility increases\nTesting error rate: U-shaped with minimum where bias and variance are simultaneously minimized\n\n\n\nQuestion 4\n\nYou will now think of some real-life applications for statistical learning.\n\n\n\nDescribe three real-life applications in which classification might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer.\n\n\n\n\nDescribe three real-life applications in which regression might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer.\n\n\n\n\nDescribe three real-life applications in which cluster analysis might be useful.\n\n\n\n\nQuestion 5\n\nWhat are the advantages and disadvantages of a very flexible (versus a less flexible) approach for regression or classification? Under what circumstances might a more flexible approach be preferred to a less flexible approach? When might a less flexible approach be preferred?\n\n\n\nQuestion 6\n\nDescribe the differences between a parametric and a non-parametric statistical learning approach. What are the advantages of a para- metric approach to regression or classification (as opposed to a non- parametric approach)? What are its disadvantages?\n\n\n\nQuestion 7\n\nThe table below provides a training data set containing six observations, three predictors, and one qualitative response variable.\n\n\n\n\n&gt;\nObs.\n\\(X_1\\)\n\\(X_2\\)\n\\(X_3\\)\n\n\n\n\n1\n0\n3\n0\nRed\n\n\n2\n2\n0\n0\nRed\n\n\n3\n0\n1\n3\nRed\n\n\n4\n0\n1\n2\nGreen\n\n\n5\n-1\n0\n1\nGreen\n\n\n6\n1\n1\n1\nRed\n\n\n\n\nSuppose we wish to use this data set to make a prediction for \\(Y\\) when \\(X_1 = X_2 = X_3 = 0\\) using \\(K\\)-nearest neighbors.\n\n\n\nCompute the Euclidean distance between each observation and the test point, \\(X_1 = X_2 = X_3 = 0\\).\n\n\n\n\nWhat is our prediction with K = 1? Why?\n\n\n\n\nWhat is our prediction with K = 3? Why?\n\n\n\n\nIf the Bayes decision boundary in this problem is highly non- linear, then would we expect the best value for K to be large or small? Why?",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "isl-2.html#lab",
    "href": "isl-2.html#lab",
    "title": "3  Statistical learning",
    "section": "3.2 Lab",
    "text": "3.2 Lab\n&lt; just basic R commands &gt;",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "islr-2.html",
    "href": "islr-2.html",
    "title": "\n3  Statistical learning\n",
    "section": "",
    "text": "3.1 Notes",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "islr-2.html#notes",
    "href": "islr-2.html#notes",
    "title": "\n3  Statistical learning\n",
    "section": "",
    "text": "3.1.1 What is statistical learning?\nSuppose that we observe a quantitative response \\(Y\\) and \\(p\\) different predictors, \\(X_1, X_2, \\ldots , X_p\\). We assume that there is some relationship between \\(Y\\) and \\(X = (X_1, X_2, \\ldots, Xp)\\), which can be written in the very general form\n\\[\nY = f(X) + \\epsilon\n\\]\nHere \\(f\\) is some fixed but unknown function of \\(X_1, \\ldots , X_p\\), and \\(\\epsilon\\) is a random error term, which is independent of \\(X\\) and has mean zero. In this formulation, \\(f\\) represents the systematic information that \\(X\\) provides about \\(Y\\).\nIn essence, statistical learning refers to a set of approaches for estimating \\(f\\).\nWhy estimate \\(f\\)?\nThere are two main reasons that we may wish to estimate \\(f\\): prediction and inference.\nPrediction\nIn many situations, a set of inputs \\(X\\) are readily available, but the output \\(Y\\) cannot be easily obtained. In this setting, since the error term averages to zero, we can predict \\(Y\\) using\n\\[\n\\hat{Y} = \\hat{f}(X),\n\\]\nwhere \\(\\hat{f}\\) represents our estimate for \\(f\\) , and \\(\\hat{Y}\\) represents the resulting prediction for \\(Y\\). In this setting, \\(\\hat{f}\\) is often treated as a black box, in the sense that one is not typically concerned with the exact form of \\(\\hat{f}\\), provided that it yields accurate predictions for \\(Y\\).\nThe accuracy of \\(\\hat{Y}\\) as a prediction for \\(Y\\) depends on two quantities, which we will call the reducible error and the irreducible error. In general, \\(\\hat{f}\\) will not be a perfect estimate for \\(f\\), and this inaccuracy will introduce some error. This error is reducible because we can potentially improve the accuracy of \\(\\hat{f}\\) by using the most appropriate statistical learning technique to estimate \\(f\\). However, even if it were possible to form a perfect estimate for \\(f\\), so that our estimated response took the form \\(\\hat{Y} = f(X)\\), our prediction would still have some error in it! This is because \\(Y\\) is also a function of \\(\\epsilon\\), which, by definition, cannot be predicted using \\(X\\). Therefore, variability associated with \\(\\epsilon\\) also affects the accuracy of our predictions. This is known as the irreducible error, because no matter how well we estimate \\(f\\), we cannot reduce the error introduced by \\(\\epsilon\\).\nWhy is the irreducible error larger than zero? The quantity \\(\\epsilon\\) may contain unmeasured variables that are useful in predicting \\(Y\\): since we don’t measure them, \\(f\\) cannot use them for its prediction. The quantity \\(\\epsilon\\) may also contain unmeasurable variation.\nConsider a given estimate \\(\\hat{f}\\) and a set of predictors \\(X\\), which yields the prediction \\(\\hat{Y} = \\hat{f}(X)\\). Assume for a moment that both \\(\\hat{f}\\) and \\(X\\) are fixed, so that the only variability comes from \\(\\epsilon\\). Then, we can say:\n\nwhere \\(E(Y − \\hat{Y})^2\\) represents the average, or expected value, of the squared difference between the predicted and actual value of \\(Y\\), and \\(Var(\\epsilon)\\) represents the variance associated with the error term \\(\\epsilon\\).\nThe focus of this book is on techniques for estimating \\(f\\) with the aim of minimizing the reducible error. It is important to keep in mind that the irreducible error will always provide an upper bound on the accuracy of our prediction for \\(Y\\). This bound is almost always unknown in practice.\nInference\nWe are often interested in understanding the association between \\(Y\\) and \\(X_1, \\ldots , X_p\\). In this situation we wish to estimate \\(f\\), but our goal is not necessarily to make predictions for \\(Y\\). Now \\(\\hat{f}\\) cannot be treated as a black box, because we need to know its exact form. In this setting, one may be interested in answering the following questions:\n\nWhich predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with \\(Y\\). Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application.\nWhat is the relationship between the response and each predictor? Some predictors may have a positive relationship with \\(Y\\), in the sense that larger values of the predictor are associated with larger values of \\(Y\\). Other predictors may have the opposite relationship. Depending on the complexity of \\(f\\), the relationship between the response and a given predictor may also depend on the values of the other predictors.\nCan the relationship between \\(Y\\) and each predictor be adequately summarized using a linear equation, or is the relationship more complicated? Historically, most methods for estimating \\(f\\) have taken a linear form. In some situations, such an assumption is reasonable or even desirable. But often the true relationship is more complicated, in which case a linear model may not provide an accurate representation of the relationship between the input and output variables.\nHow do we estimate \\(f\\)?\nThroughout this book, we explore many linear and non-linear approaches for estimating \\(f\\). However, these methods generally share certain characteristics. Here is an overview.\nNote we will always assume that we have observed a set of \\(n\\) different data points, called the training data because we will use these observations to train, or teach, our method how to estimate \\(f\\).\nOur goal is to apply a statistical learning method to the training data in order to estimate the unknown function \\(f\\). In other words, we want to find a function \\(\\hat{f}\\) such that \\(Y \\approx \\hat{f}(X)\\) for any observation \\((X,Y)\\). Broadly speaking, most statistical learning methods for this task can be characterized as either parametric or non-parametric. We now briefly discuss these two types of approaches.\nParametric\nParametric methods involve a two-step model-based approach.\nStep 1\n\nFirst, we make an assumption about the functional form, or shape, of \\(f\\). For example, one very simple assumption is that \\(f\\) is linear in \\(X\\):\n\n\\[\nf(X) = \\beta_0 + \\beta_1 X_1 + \\ldots + \\beta_p X_p\n\\]\n\nThis is a linear model. Once we have assumed that \\(f\\) is linear, the problem of estimating \\(f\\) is greatly simplified. Instead of having to estimate an entirely arbitrary \\(p\\)-dimensional function \\(f(X)\\), one only needs to estimate the p+1 coefficients \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\).\n\nStep 2\n\nAfter a model has been selected, we need a procedure that uses the training data to fit or train the model. In the case of the linear model, we need to estimate the parameters \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\).That is,we want to find values of these parameters such that\n\n\\[\nY \\approx \\beta_0 + \\beta_1 X_1 + \\ldots + \\beta_p X_p\n\\]\n\nThe most common approach to fitting the model above is referred to as (ordinary) least squares. However, least squares is one of many possible ways to fit the linear model.\n\nThe model-based approach just described is referred to as parametric; it reduces the problem of estimating \\(f\\) down to one of estimating a set of parameters. Assuming a parametric form for \\(f\\) simplifies the problem of estimating \\(f\\) because it is generally much easier to estimate a set of parameters, such as \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\) in the linear model, than it is to fit an entirely arbitrary function \\(f\\). The potential disadvantage of a parametric approach is that the model we choose will usually not match the true unknown form of \\(f\\). If the chosen model is too far from the true \\(f\\), then our estimate will be poor. We can try to address this problem by choosing flexible models that can fit many different possible functional forms for \\(f\\). But in general, fitting a more flexible model requires estimating a greater number of parameters. These more complex models can lead to a phenomenon known as overfitting the data, which essentially means they follow the errors, or noise, too closely.\nNon-parametric\nNon-parametric methods do not make explicit assumptions about the functional form of \\(f\\). Instead they seek an estimate of \\(f\\) that gets as close to the data points as possible without being too rough or wiggly. Such approaches can have a major advantage over parametric approaches: by avoiding the assumption of a particular functional form for \\(f\\), they have the potential to accurately fit a wider range of possible shapes for \\(f\\).\nAny parametric approach brings with it the possibility that the functional form used to estimate \\(f\\) is very different from the true \\(f\\), in which case the resulting model will not fit the data well. In contrast, non-parametric approaches completely avoid this danger, since essentially no assumption about the form of \\(f\\) is made. But non-parametric approaches do suffer from a major disadvantage: since they do not reduce the problem of estimating \\(f\\) to a small number of parameters, a very large number of observations (far more than is typically needed for a parametric approach) is required in order to obtain an accurate estimate for \\(f\\).\nBe careful of overfitting though, non-parametric methods can fit the data perfectly if complex enough, which causes the fit obtained to not yield accurate estimates of the response on new observations that were not part of the original training data set.\n\nThe trade-off between prediction accuracy and model interpretability\nOf the many methods that we examine in this book, some are less flexible, or more restrictive, in the sense that they can produce just a relatively small range of shapes to estimate \\(f\\). For example, linear regression is a relatively inflexible approach, because it can only generate linear functions (smooth lines / planes). Other methods are considerably more flexible because they can generate a much wider range of possible shapes to estimate \\(f\\).\nOne might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very flexible approach? There are several reasons that we might prefer a more restrictive model. If we are mainly interested in inference, then restrictive models are much more interpretable. For instance, when inference is the goal, the linear model may be a good choice since it will be quite easy to understand the relationship between \\(Y\\) and \\(X_1, X_2, \\ldots, X_p\\). In contrast, very flexible approaches, such as the splines and boosting methods can lead to such complicated estimates of \\(f\\) that it is difficult to understand how any individual predictor is associated with the response.\nHere is an illustration of the trade-off between flexibility and interpretability for some of the methods that we cover in this book.\n\nLeast squares linear regression is relatively inflexible but is quite interpretable. The lasso relies upon the linear model but uses an alternative fitting procedure for estimating the coefficients \\(\\beta_0, \\beta_1, \\ldots, \\beta_p\\). The new procedure is more restrictive in estimating the coefficients, and sets a number of them to exactly zero. Hence in this sense the lasso is a less flexible approach than linear regression. It is also more interpretable than linear regression, because in the final model the response variable will only be related to a small subset of the predictors — namely, those with nonzero coefficient estimates.\nGeneralized additive models (GAMs), discussed in Chapter 7, instead extend the linear model to allow for certain non-linear relationships. Consequently, GAMs are more flexible than linear regression. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve. Finally, fully non-linear methods such as bagging, boosting, support vector machines with non-linear kernels, and neural networks (deep learning) are highly flexible approaches that are harder to interpret.\nWe have established that when inference is the goal, there are clear advantages to using simple and relatively inflexible statistical learning methods. In some settings, however, we are only interested in prediction, and the interpretability of the predictive model is simply not of interest; our sole requirement for the algorithm is that it predict accurately (i.e. interpretability is not a concern). In this setting, we might expect that it will be best to use the most flexible model available. Surprisingly, this is not always the case! We will often obtain more accurate predictions using a less flexible method. This phenomenon, which may seem counterintuitive at first glance, has to do with the potential for overfitting in highly flexible methods.\nSupervised vs unsupervised learning\nMost statistical learning problems fall in to one of two categories: supervised or unsupervised. The examples that we have discussed so far in this chapter all fall into the supervised learning domain. For each observation of the predictor measurement(s) \\(x_i, i = 1, \\ldots , n\\) there is an associated response measurement \\(y_i\\). We wish to fit a model that relates the response to the predictors, with the aim of accurately predicting the response for future observations (prediction) or better understanding the relationship between the response and the predictors (inference). Many classical statistical learning methods such as linear regression and logistic regression, as well as more modern approaches such as GAM, boosting, and support vector machines, operate in the supervised learning domain. The vast majority of this book is devoted to this setting.\nBy contrast, unsupervised learning describes the somewhat more challenging situation in which for every observation \\(i = 1, \\ldots, n\\), we observe a vector of measurements \\(x_i\\) but no associated response \\(y_i\\). It is not possible to fit a linear regression model, since there is no response variable to predict. In this setting, we are in some sense working blind; the situation is referred to as unsupervised because we lack a response variable that can supervise our analysis. What sort of statistical analysis is possible? We can seek to understand the relationships between the variables or between the observations. One statistical learning tool that we may use in this setting is cluster analysis, or clustering. The goal of cluster analysis is to ascertain, on the basis of \\(x_1, \\ldots, x_n\\), whether the observations fall into relatively distinct groups.\n\nHowever, in practice the group memberships are unknown, and the goal is to determine the group to which each observation belongs. A clustering method could not be expected to assign all of the overlapping points to their correct group.\nIn the example above, there are only two variables, and so one can simply visually inspect the scatterplots of the observations in order to identify clusters. However, in practice, we often encounter data sets that contain many more than two variables. In this case, we cannot easily plot the observations. For instance, if there are \\(p\\) variables in our data set, then \\(p(p − 1)/2\\) distinct scatterplots can be made, and visual inspection is simply not a viable way to identify clusters. For this reason, automated clustering methods are important.\nMany problems fall naturally into the supervised or unsupervised learning paradigms. However, sometimes the question of whether an analysis should be considered supervised or unsupervised is less clear-cut. For instance, suppose that we have a set of \\(n\\) observations. For \\(m\\) of the observations, where \\(m &lt; n\\), we have both predictor measurements and a response measurement. For the remaining \\(n − m\\) observations, we have predictor measurements but no response measurement. Such a scenario can arise if the predictors can be measured relatively cheaply but the corresponding responses are much more expensive to collect. We refer to this setting as a semi-supervised learning problem. In this setting, we wish to use a statistical learning method that can incorporate the \\(m\\) observations for which response measurements are available as well as the \\(n − m\\) observations for which they are not. Although this is an interesting topic, it is beyond the scope of this book.\nRegression vs classification problems\nWe tend to refer to problems with a quantitative response as regression problems, while those involving a qualitative response are often referred to as classification problems. However, the distinction is not always that crisp. Least squares linear regression is used with a quantitative response, whereas logistic regression is typically used with a qualitative (two-class, or binary) response. Thus, despite its name, logistic regression is a classification method. But since it estimates class probabilities, it can be thought of as a regression method as well. Some statistical methods, such as \\(K\\)-nearest neighbors and boosting, can be used in the case of either quantitative or qualitative responses.\nWe tend to select statistical learning methods on the basis of whether the response is quantitative or qualitative; i.e. we might use linear regression when quantitative and logistic regression when qualitative. However, whether the predictors are qualitative or quantitative is generally considered less important. Most of the statistical learning methods discussed in this book can be applied regardless of the predictor variable type, provided that any qualitative predictors are properly coded before the analysis is performed.\n\n3.1.2 Assessing model accuracy\nOne of the key aims of this book is to introduce the reader to a wide range of statistical learning methods that extend far beyond the standard linear regression approach. Why is it necessary to introduce so many different statistical learning approaches, rather than just a single best method? There is no free lunch in statistics: no one method dominates all others over all possible data sets. On a particular data set, one specific method may work best, but some other method may work better on a similar but different data set. Hence it is an important task to decide for any given set of data which method produces the best results. Selecting the best approach can be one of the most challenging parts of performing statistical learning in practice.\nNow, we discuss some of the most important concepts that arise in selecting a statistical learning procedure for a specific data set.\nMeasuring the quality of fit\nIn order to evaluate the performance of a statistical learning method on a given data set, we need some way to measure how well its predictions actually match the observed data. That is, we need to quantify the extent to which the predicted response value for a given observation is close to the true response value for that observation. In the regression setting, the most commonly-used measure is the mean squared error (MSE), given by\n\\[\nMSE = \\frac{1}{n} \\sum_{i = 1}^n (y_i - \\hat{f}(x_i))^2\n\\] The MSE will be small if the predicted responses are very close to the true responses, and will be large if for some of the observations, the predicted and true responses differ substantially.\nThis MSE is computed using the training data that was used to fit the model, and so should more accurately be referred to as the training MSE. But in general, we do not really care how well the method works training on the training data. Rather, we are interested in the accuracy of the predictions that we obtain when we apply our method to previously unseen test data. To state it more mathematically, suppose that we fit our statistical learn- ing method on our training observations \\(\\{(x_1,y_1), (x_2,y_2), \\ldots, (x_n,y_n)\\}\\), and we obtain the estimate \\(\\hat{f}\\). We can then compute \\(\\hat{f}(x_1), \\hat{f}(x_2), \\ldots , \\hat{f}(x_n)\\). If these are approximately equal to \\(y_1, y_2, \\ldots, y_n\\), then the training MSE is small. However, we are really not interested in whether \\(\\hat{f}(x_i) \\approx y_i\\); instead, we want to know whether \\(\\hat{f}(x_0)\\) is approximately equal to \\(y_0\\), where \\((x_0,y_0)\\) is a previously unseen test observation not used to train the statistical learning method. We want to choose the method that gives the lowest test MSE, as opposed to the lowest training MSE. In other words, if we had a large number of test observations, we could compute the average squared prediction error for these test observations \\((x_0,y_0)\\):\n\\[\n\\text{Ave}(y_0 - \\hat{f}(x_0))^2\n\\]\nWe’d like to select the model for which this quantity is as small as possible.\nHow can we go about trying to select a method that minimizes the test MSE? In some settings, we may have a test data set available. We can then simply evaluate the above formula on the test observations, and select the learning method for which the test MSE is smallest. But what if no test observations are available? In that case, one might imagine simply selecting a statistical learning method that minimizes the training MSE. This seems like it might be a sensible approach, since the training MSE and the test MSE appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods specifically estimate coefficients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, but the test MSE is often much larger.\nThe figure below illustrates this concept. In the left-hand panel, we have generated observations from some \\(f(X)\\) with the true \\(f\\) given by the black curve. The orange, blue and green curves illustrate three possible estimates for \\(f\\) obtained using methods with increasing levels of flexibility.\n\nThe blue and green curves were produced using smoothing splines. It is clear that as the level of flexibility increases, the curves fit the observed data more closely. The green curve is the most flexible and matches the data very well; however, we observe that it fits the true \\(f\\) (shown in black) poorly because it is too wiggly.\nOn the right panel, the grey curve displays the average training MSE as a function of flexibility, or more formally the degrees of freedom, for a number of smoothing splines. The degrees of freedom is a quantity that summarizes the flexibility of a curve. A more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve (i.e. more error dfs; a more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve). The training MSE declines monotonically as flexibility increases. In this example the true \\(f\\) is non-linear, and so the orange linear fit is not flexible enough to estimate f well. The green curve has the lowest training MSE of all three methods, since it corresponds to the most flexible of the three curves fit in the left-hand panel.\nIn this example, we know the true function \\(f\\), and so we can also compute the test MSE over a very large test set, as a function of flexibility. (Of course, in general \\(f\\) is unknown, so this will not be possible. The horizontal dashed line indicates \\(\\text{Var}(\\epsilon)\\), the irreducible error, which corresponds to the lowest achievable test MSE among all possible methods. As the flexibility of the statistical learning method increases, we observe a monotone decrease in the training MSE and a U-shape in the test MSE (red line). This is a fundamental property of statistical learning that holds regardless of the particular data set at hand and regardless of the statistical method being used. As model flexibility increases, training MSE will decrease, but the test MSE may not. When a given method yields a small training MSE but a large test MSE, we are said to be overfitting the data. This happens because our statistical learning procedure is working too hard to find patterns in the training data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function \\(f\\). When we overfit the training data, the test MSE will be very large because the supposed patterns that the method found in the training data simply don’t exist in the test data. Note that regardless of whether or not overfitting has occurred, we almost always expect the training MSE to be smaller than the test MSE because most statistical learning methods either directly or indirectly seek to minimize the training MSE. Overfitting refers specifically to the case in which a less flexible model would have yielded a smaller test MSE.\nHere is another example that displays the same patterns. However, because the truth is close to linear, the test MSE only decreases slightly before increasing again, so that the orange least squares fit is substantially better than the highly flexible green curve.\n\nFinally, here is another example in which \\(f\\) is highly non-linear. Now there is a rapid decrease in both curves before the test MSE starts to increase slowly.\n\nIn practice, one can usually compute the training MSE with relative ease, but estimating test MSE is considerably more difficult because usually no test data are available. As the previous three examples illustrate, the flexibility level corresponding to the model with the minimal test MSE can vary considerably among data sets. Throughout this book, we discuss a variety of approaches that can be used in practice to estimate this minimum point. One important method is cross-validation, which is a method for estimating test MSE using the training data.\nThe bias-variance trade-off\nThe U-shape observed in the test MSE curves turns out to be the result of two competing properties of statistical learning methods. It is possible to show that the expected test MSE, for a given value \\(x_0\\), can always be decomposed into the sum of three fundamental quantities: the variance of \\(\\hat{f}(x_0)\\), the squared bias of \\(f(x_0)\\) and the variance of the error terms \\(\\epsilon\\). That is,\n\\[\nE\\big(y_o - \\hat{f}(x_0)\\big)^2 = \\text{Var}(\\hat{f}(x_0)) + [\\text{Bias}(\\hat{f}(x_0))]^2 + \\text{Var}(\\epsilon)\n\\]\n\nHere, the notation \\(E\\big(y_o - \\hat{f}(x_0)\\big)^2\\) defines the expected test MSE at \\(x_0\\), and refers to the average test MSE that we would obtain if we repeatedly estimated \\(f\\) using a large number of training sets, and tested each at \\(x_0\\). The overall expected test MSE can be computed by averaging \\(E\\big(y_o - \\hat{f}(x_0)\\big)^2\\) over all possible values of \\(x_0\\) in the test set.\nThis equation tells us that in order to minimize the expected test error, we need to select a statistical learning method that simultaneously achieves low variance and low bias. Note that variance is inherently a nonnegative quantity, and squared bias is also nonnegative. Hence, we see that the expected test MSE can never lie below \\(\\text{Var}(\\epsilon)\\), the irreducible error.\nWhat do we mean by the variance and bias of a statistical learning method? Variance refers to the amount by which \\(\\hat{f}\\) would change if we estimated it using a different training data set. Since the training data are used to fit the statistical learning method, different training data sets will result in a different \\(\\hat{f}\\). But ideally the estimate for f should not vary too much between training sets. However, if a method has high variance then small changes in the training data can result in large changes in \\(\\hat{f}\\). In general, more flexible statistical methods have higher variance.\nOn the other hand, bias refers to the error that is introduced by approximating a real-life problem, which may be extremely complicated, by a much simpler model. Generally, more flexible methods result in less bias.\nAs a general rule, as we use more flexible methods, the variance will increase and the bias will decrease. The relative rate of change of these two quantities determines whether the test MSE increases or decreases. As we increase the flexibility of a class of methods, the bias tends to initially decrease faster than the variance increases. Consequently, the expected test MSE declines. However, at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. When this happens the test MSE increases. For the previous examples, here are the variance, bias curves:\n\nThis shows that variance is an increasing function of flexibility, and bias is a decreasing function. The goal is to find the balance point. This trade-off is one of the most important recurring themes in this book.\nIn a real-life situation in which \\(f\\) is unobserved, it is generally not possible to explicitly compute the test MSE, bias, or variance for a statistical learning method. Nevertheless, one should always keep the bias-variance trade-off in mind. In this book we explore methods that are extremely flexible and hence can essentially eliminate bias. However, this does not guarantee that they will outperform a much simpler method such as linear regression. To take an extreme example, suppose that the true \\(f\\) is linear. In this situation linear regression will have no bias, making it very hard for a more flexible method to compete. In contrast, if the true \\(f\\) is highly non-linear and we have an ample number of training observations, then we may do better using a highly flexible approach. Later, we discuss cross-validation, which is a way to estimate the test MSE using the training data.\nThe classification setting\nThus far, our discussion of model accuracy has been focused on the regression setting. But many of the concepts that we have encountered, such as the bias-variance trade-off, transfer over to the classification setting with only some modifications due to the fact that \\(y_i\\) is no longer quantitative. Suppose that we seek to estimate \\(f\\) on the basis of training observations \\(\\{(x_1,y_1), \\ldots, (x_n,y_n)\\}\\), where now \\(y_1, \\ldots , y_n\\) are qualitative. The most common approach for quantifying the accuracy of our estimate \\(\\hat{f}\\) is the training error rate, the proportion of mistakes that are made if we apply our estimate \\(\\hat{f}\\) to the training observations:\n\\[\n\\frac{1}{n} \\sum_{i = 1}^n I(y_i \\ne \\hat{y}_i)\n\\]\nHere \\(\\hat{y}_i\\) is the predicted class label for the \\(i\\)th observation using \\(\\hat{f}\\). And \\(I(y_i \\ne \\hat{y}_i))\\) is an indicator variable that equals 1 if \\(y_i \\ne \\hat{y}_i\\) and zero if \\(y_i = \\hat{y}_i\\) (i.e. indicator if wrong). Thus, the above equation computes the fraction of incorrect classifications.\nThe test error rate associated with a set of test observations of the form \\((x_0, y_0)\\) is given by\n\\[\n\\text{Ave}(I(y_0 \\ne \\hat{y}_0))\n\\]\nA good classifier is one for which the test error is smallest.\nThe Bayes classifier\nIt is possible to show (though the proof is outside of the scope of this book) that the test error rate given in is minimized, on average, by a very simple classifier that assigns each observation to the most likely class, given its predictor values. In other words, we should simply assign a test observation with predictor vector \\(x_0\\) to the class \\(j\\) for which\n\\[\n\\text{Pr}(Y = j \\mid X = x_0)\n\\]\nis the largest. Note that the above formula is a conditional probability: it is the probability that \\(Y = j\\), given the observed predictor vector \\(x_0\\). This very simple classifier is called the Bayes classifier. In a two-class problem where there are only two possible response values, say class 1 or class 2, the Bayes classifier corresponds to predicting class one if \\(\\text{Pr}(Y = j \\mid X = x_0) &gt; 0.5\\), and class two otherwise.\nHere is an example:\n\nFor each value of \\(X_1\\) and \\(X_2\\), there is a different probability of the response being orange or blue. Since this is simulated data, we know how the data were generated and we can calculate the conditional probabilities for each value of \\(X_1\\) and \\(X_2\\). The purple dashed line represents the points where the probability is exactly 50%. This is called the Bayes decision boundary.\nThe Bayes classifier produces the lowest possible test error rate, called the Bayes error rate. Since the Bayes classifier will always choose the class for which the above formula is largest, the error rate will be \\(1 − \\text{max}_j \\, \\text{Pr}(Y = j \\mid X = x_0)\\) at \\(X = x_0\\). In general, the overall Bayes error rate is given by\n\\[\n1 - E\\big(\\underset{j}{\\text{max}} \\, \\text{Pr}(Y = j \\mid X)\\big)\n\\]\nwhere the expectation averages the probability over all possible values of \\(X\\). The Bayes error rate is analogous to the irreducible error, discussed earlier.\n\n\\(K\\)-Nearest neighbors\nIn theory we would always like to predict qualitative responses using the Bayes classifier. But for real data, we do not know the conditional distribution of \\(Y\\) given \\(X\\), and so computing the Bayes classifier is impossible. Therefore, the Bayes classifier serves as an unattainable gold standard against which to compare other methods.\n\nMany approaches attempt to estimate the conditional distribution of \\(Y\\) given \\(X\\), and then classify a given observation to the class with highest estimated probability. One such method is the K-nearest neighbors (KNN) classifier. Given a positive integer \\(K\\) and a test observation \\(x_0\\), the KNN classifier first identifies the \\(K\\) points in the training data that are closest to \\(x_0\\), represented by \\(\\cal{N}_0\\). It then estimates the conditional probability for class \\(j\\) as the fraction of points in \\(\\cal{N}_0\\) whose response values equal \\(j\\):\n\\[\n\\text{Pr}(Y = j \\mid X = x_0) = \\frac{1}{K}\\sum_{i \\in \\cal{N}_0} I(y_i = j)\n\\]\nFinally, KNN classifies the test observation \\(x_0\\) to the class with the largest probability from the equation above.\nHere is an example of the KNN approach:\n\nDespite the fact that it is a very simple approach, KNN can often produce classifiers that are surprisingly close to the optimal Bayes classifier. Note that even though the true distribution is not known by the KNN classifier, the KNN decision boundary is very close to that of the Bayes classifier.\n\nHowever, the choice of \\(K\\) has a drastic effect on the KNN classifier obtained.\n\nWhen \\(K = 1\\), the decision boundary is overly flexible and finds patterns in the data that don’t correspond to the Bayes decision boundary. This corresponds to a classifier that has low bias but very high variance. As \\(K\\) grows, the method becomes less flexible and produces a decision boundary that is close to linear. This corresponds to a low-variance but high-bias classifier.\nJust as in the regression setting, there is not a strong relationship between the training error rate and the test error rate. With \\(K = 1\\), the KNN training error rate is 0, but the test error rate may be quite high. In general, as we use more flexible classification methods, the training error rate will decline but the test error rate may not.\n\nAs \\(1/K\\) increases, the method becomes more flexible. As in the regression setting, the training error rate consistently declines as the flexibility increases. However, the test error exhibits a characteristic U-shape, declining at first (with a minimum at approximately \\(K = 10\\)) before increasing again when the method becomes excessively flexible and overfits.\nIn both the regression and classification settings, choosing the correct level of flexibility is critical to the success of any statistical learning method. The bias-variance trade-off, and the resulting U-shape in the test error, can make this a difficult task.",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "islr-2.html#lab",
    "href": "islr-2.html#lab",
    "title": "\n3  Statistical learning\n",
    "section": "\n3.2 Lab",
    "text": "3.2 Lab\n&lt; just basic R commands &gt;",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "islr-2.html#exercises",
    "href": "islr-2.html#exercises",
    "title": "\n3  Statistical learning\n",
    "section": "\n3.3 Exercises",
    "text": "3.3 Exercises\n\n3.3.1 Conceptual\nQuestion 1\n\nFor each of parts (a) through (d), indicate whether we would generally expect the performance of a flexible statistical learning method to be better or worse than an inflexible method. Justify your answer.\n\nThe sample size \\(n\\) is extremely large, and the number of predictors \\(p\\) is small.\n\n\nA flexible model will perform better than an inflexible model because there are ample degrees of freedom to estimate many parameters and still have many leftover for error df.\n\n\nThe number of predictors \\(p\\) is extremely large, and the number of observations \\(n\\) is small.\n\n\nAn inflexible will be better because there is a high chance of some predictors being randomly associated.\n\n\nThe relationship between the predictors and response is highly non-linear.\n\n\nA flexible model will perform better because it can pick up on the non-linear trends better.\n\n\nThe variance of the error terms, i.e. \\(\\sigma^2 = \\text{Var}(\\epsilon)\\), is extremely high.\n\n\nInflexible model will be better because the flexible model will pick up on the noise a lot better even though it is not related to the relationship to the \\(X\\)s.\nQuestion 2\n\nExplain whether each scenario is a classification or regression problem, and indicate whether we are most interested in inference or prediction. Finally, provide \\(n\\) and \\(p\\).\n\nWe collect a set of data on the top 500 firms in the US. For each firm we record profit, number of employees, industry and the CEO salary. We are interested in understanding which factors affect CEO salary.\n\n\nRegression; inference; \\(n = 500, p = 3\\)\n\n\nWe are considering launching a new product and wish to know whether it will be a success or a failure. We collect data on 20 similar products that were previously launched. For each product we have recorded whether it was a success or failure, price charged for the product, marketing budget, competition price, and ten other variables.\n\n\nClassification; prediction; \\(n = 20, p = 13\\)\n\n\nWe are interested in predicting the % change in the USD/Euro exchange rate in relation to the weekly changes in the world stock markets. Hence we collect weekly data for all of 2012. For each week we record the % change in the USD/Euro, the % change in the US market, the % change in the British market, and the % change in the German market.\n\n\nRegression; prediction; \\(n = 52, p = 3\\).\nQuestion 3\n\nWe now revisit the bias-variance decomposition.\n\nProvide a sketch of typical (squared) bias, variance, training error, test error, and Bayes (or irreducible) error curves, on a single plot, as we go from less flexible statistical learning methods towards more flexible approaches. The x-axis should represent the amount of flexibility in the method, and the y-axis should represent the values for each curve. There should be five curves. Make sure to label each one.\n\n\n&lt; !!! get from ipad &gt;\n\n\n\nExplain why each of the five curves has the shape displayed in part (a).\n\n\n\nBias: Decreases until leveling off as flexibility increases (nears zero)\nVariance: Increases faster as flexibility increases\nBayes (irreducible error): Constant, unrelated to flexibility (\\(X\\))\nTraining error rate: Decrease monotonically as flexibility increases\nTesting error rate: U-shaped with minimum where bias and variance are simultaneously minimized\nQuestion 4\n\nYou will now think of some real-life applications for statistical learning.\n\nDescribe three real-life applications in which classification might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer.\n\n\n\nInsurance, predict whether a policyholder will have a claim or not. Response is binary, predictors are variables such as credit score, age of business, type of business, etc. Goal is prediction, want to see if a new customer is likely to have a claim.\n&lt; good enough &gt;\n\n\n\nDescribe three real-life applications in which regression might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer.\n\n\nInsurance, predict the amount of a claim. Response is claim size in dollars, same predictors as in a.\n\n\nDescribe three real-life applications in which cluster analysis might be useful.\n\n\nInsurance, determining if a business is low, medium or high risk. Same predictors as a.\nQuestion 5\n\nWhat are the advantages and disadvantages of a very flexible (versus a less flexible) approach for regression or classification? Under what circumstances might a more flexible approach be preferred to a less flexible approach? When might a less flexible approach be preferred?\n\n\nFlexible models can pick up on non-linear patterns in regression and are more useful in prediction when we are only concerned with accuracy, especially with large \\(n\\); and they are less biased, however more variable. A less flexible approach is better for inference when we want to understand the relationship(s) between \\(Y\\) and \\(X\\); more bias, but less variable.\nQuestion 6\n\nDescribe the differences between a parametric and a non-parametric statistical learning approach. What are the advantages of a parametric approach to regression or classification (as opposed to a non-parametric approach)? What are its disadvantages?\n\nParametric approach assumes a functional form of the response and one needs to only estimate parameters, which is a simpler task. And because of the assumption, the model is more interpretable. However a non-parametric method just fits the data as best as possible. Non-parametric methods can be less biased, but are more variable, especially as the complexity increases and more data is needed because of the more parameters being estimated.\nQuestion 7\n\nThe table below provides a training data set containing six observations, three predictors, and one qualitative response variable.\n\n\n\nSuppose we wish to use this data set to make a prediction for \\(Y\\) when \\(X_1 = X_2 = X_3 = 0\\) using \\(K\\)-nearest neighbors.\n\n\n\nCompute the Euclidean distance between each observation and the test point, \\(X_1 = X_2 = X_3 = 0\\).\n\n\n\n# read in data\ndf &lt;- tibble(\n  x1 = c(0, 2, 0, 0, -1, 1),\n  x2 = c(3, 0, 1, 1, 0, 1),\n  x3 = c(0, 0, 3, 2, 1, 1),\n  y = c(\"Red\", \"Red\", \"Red\", \"Green\", \"Green\", \"Red\")\n)\n\n# define function to calculate euclidean distance \n# -&gt; sum function calculates the sum of the squares of absolute difference between  corresponding elements of vec_1 and vec_2 \ncalc_euc_dist &lt;- function(vec_1, vec_2) {\n  subtract(vec_1, vec_2) %&gt;% raise_to_power(2) %&gt;% sum %&gt;% sqrt\n} \n\n# calculate euclidean distance for each observation\ndf %&gt;%\n  rowwise() %&gt;% \n  mutate(euc_dist = calc_euc_dist(c(x1, x2, x3), rep(0, 3)),\n         .keep = \"none\")\n\n# A tibble: 6 × 1\n# Rowwise: \n  euc_dist\n     &lt;dbl&gt;\n1     3   \n2     2   \n3     3.16\n4     2.24\n5     1.41\n6     1.73\n\n\n\n\nWhat is our prediction with K = 1? Why?\n\n\n\ndf %&gt;%\n  rowwise() %&gt;% \n  mutate(euc_dist = calc_euc_dist(c(x1, x2, x3), rep(0, 3)),\n         .keep = \"unused\") %&gt;% \n  ungroup() %&gt;% \n  slice_min(order_by = euc_dist, n = 1)\n\n# A tibble: 1 × 2\n  y     euc_dist\n  &lt;chr&gt;    &lt;dbl&gt;\n1 Green     1.41\n\n\nGreen is our prediction\n\n\nWhat is our prediction with K = 3? Why?\n\n\n\n# turn above into a function\n\n# define function to do KNN prediction for a particular test point\nalgorithm_knn &lt;- function(df, y, x0, k = 1, final_result = FALSE) {\n \n  # get column names\n  nms = df %&gt;% \n    colnames\n  \n  # standardized column names\n  # -&gt; place response variable first and renamed\n  # -&gt; followed by explanatory variables renamed x1, x2, ... (unnecessary)\n  df_z &lt;- df %&gt;% \n    select(y = any_of(y), any_of(nms[which(nms != y)])) #%&gt;% \n    #rename_with(~ paste0(\"x\", 1:(ncol(df)-1)), .cols = any_of(nms[which(nms != y)]))\n   \n  # calculate euclidean distances\n  euc_dist = c()\n  for (i in 1:nrow(df_z)) {\n    \n    euc_dist[i] = calc_euc_dist(as.vector(df_z[i, 2:ncol(df_z)], mode = \"double\"), x0) \n    \n  }\n  \n  # create dataframe of results\n  df_dist = df_z %&gt;% \n    select(y) %&gt;% \n    bind_cols(euc_dist = euc_dist)\n    \n  # display results\n  results = df_dist %&gt;% \n    slice_min(order_by = euc_dist, n = k) %&gt;% \n    summarize(.by = y, \n              est_prob = n() / nrow(.))\n  \n  # conditionally simplify results\n  if(final_result) {\n    results %&lt;&gt;% \n      slice_min(order_by = est_prob) %&gt;% \n      select(y) %&gt;% \n      as.character\n  }\n  \n  return(results)\n  \n}\n\n# test function on K = 1\nalgorithm_knn(df, y = \"y\", x0 = rep(0, 3), k = 1, final_result = FALSE)\n\n# A tibble: 1 × 2\n  y     est_prob\n  &lt;chr&gt;    &lt;dbl&gt;\n1 Green        1\n\n# now for K = 3\nalgorithm_knn(df, y = \"y\", x0 = rep(0, 3), k = 3, final_result = FALSE)\n\n# A tibble: 2 × 2\n  y     est_prob\n  &lt;chr&gt;    &lt;dbl&gt;\n1 Green    0.333\n2 Red      0.667\n\nalgorithm_knn(df, y = \"y\", x0 = rep(0, 3), k = 3, final_result = TRUE)\n\n[1] \"Green\"\n\n# test a set of points\nx0 &lt;- tibble(\n  x1 = extraDistr::rdunif(n = 5, min = 0, max = 3),\n  x2 = extraDistr::rdunif(n = 5, min = 0, max = 3),\n  x3 = extraDistr::rdunif(n = 5, min = 0, max = 3)\n)\n\nresults &lt;- c()\nfor (i in 1:nrow(x0)) {\n  results[i] = algorithm_knn(df, y = \"y\", x0 = x0[i,], k = 3, final_result = TRUE)\n}\nresults\n\n[1] \"Red\"   \"Green\" \"Green\" \"Green\" \"Red\"  \n\n# note if results include a vector of two classes, then there was a tie. Not sure how to break ties, but could research and code something...\n\n\n\nIf the Bayes decision boundary in this problem is highly non- linear, then would we expect the best value for K to be large or small? Why?\n\n\nSmall so that the model is more flexible (high \\(k\\) leads to linear boundaries due to averaging).\n\n3.3.2 Applied\nQuestion 8\n\n# load data\ndata_college &lt;- ISLR2::College\n\n# summarize numeric variables\ndata_college %&gt;% \n  select(where(is.numeric)) %&gt;% \n  summary\n\n      Apps           Accept          Enroll       Top10perc       Top25perc    \n Min.   :   81   Min.   :   72   Min.   :  35   Min.   : 1.00   Min.   :  9.0  \n 1st Qu.:  776   1st Qu.:  604   1st Qu.: 242   1st Qu.:15.00   1st Qu.: 41.0  \n Median : 1558   Median : 1110   Median : 434   Median :23.00   Median : 54.0  \n Mean   : 3002   Mean   : 2019   Mean   : 780   Mean   :27.56   Mean   : 55.8  \n 3rd Qu.: 3624   3rd Qu.: 2424   3rd Qu.: 902   3rd Qu.:35.00   3rd Qu.: 69.0  \n Max.   :48094   Max.   :26330   Max.   :6392   Max.   :96.00   Max.   :100.0  \n  F.Undergrad     P.Undergrad         Outstate       Room.Board  \n Min.   :  139   Min.   :    1.0   Min.   : 2340   Min.   :1780  \n 1st Qu.:  992   1st Qu.:   95.0   1st Qu.: 7320   1st Qu.:3597  \n Median : 1707   Median :  353.0   Median : 9990   Median :4200  \n Mean   : 3700   Mean   :  855.3   Mean   :10441   Mean   :4358  \n 3rd Qu.: 4005   3rd Qu.:  967.0   3rd Qu.:12925   3rd Qu.:5050  \n Max.   :31643   Max.   :21836.0   Max.   :21700   Max.   :8124  \n     Books           Personal         PhD            Terminal    \n Min.   :  96.0   Min.   : 250   Min.   :  8.00   Min.   : 24.0  \n 1st Qu.: 470.0   1st Qu.: 850   1st Qu.: 62.00   1st Qu.: 71.0  \n Median : 500.0   Median :1200   Median : 75.00   Median : 82.0  \n Mean   : 549.4   Mean   :1341   Mean   : 72.66   Mean   : 79.7  \n 3rd Qu.: 600.0   3rd Qu.:1700   3rd Qu.: 85.00   3rd Qu.: 92.0  \n Max.   :2340.0   Max.   :6800   Max.   :103.00   Max.   :100.0  \n   S.F.Ratio      perc.alumni        Expend        Grad.Rate     \n Min.   : 2.50   Min.   : 0.00   Min.   : 3186   Min.   : 10.00  \n 1st Qu.:11.50   1st Qu.:13.00   1st Qu.: 6751   1st Qu.: 53.00  \n Median :13.60   Median :21.00   Median : 8377   Median : 65.00  \n Mean   :14.09   Mean   :22.74   Mean   : 9660   Mean   : 65.46  \n 3rd Qu.:16.50   3rd Qu.:31.00   3rd Qu.:10830   3rd Qu.: 78.00  \n Max.   :39.80   Max.   :64.00   Max.   :56233   Max.   :118.00  \n\n# scatterplot matrix\ndata_college[, 1:10] %&gt;% pairs\n\n\n\n\n\n\n# side-by-side boxplots\nboxplot(Outstate ~ Private, data = data_college)\n\n\n\n\n\n\n# create new variable and summarize\ndata_college %&lt;&gt;% \n  mutate(Elite = case_when(\n    Top10perc &gt; 50 ~ \"Yes\",\n    .default = \"No\"\n  ))\ntable(data_college$Elite)\n\n\n No Yes \n699  78 \n\n\nQuestion 9\n\n# load data\ndata_auto &lt;- ISLR2::Auto \n\n# determine variable types\ndata_auto %&gt;% map_chr(class)\n\n         mpg    cylinders displacement   horsepower       weight acceleration \n   \"numeric\"    \"integer\"    \"numeric\"    \"integer\"    \"integer\"    \"numeric\" \n        year       origin         name \n   \"integer\"    \"integer\"     \"factor\" \n\n# find range of each quantitative predictor\ndata_auto %&gt;% \n  select(where(is.numeric)) %&gt;% \n  reframe(across(1:ncol(.), range))\n\n   mpg cylinders displacement horsepower weight acceleration year origin\n1  9.0         3           68         46   1613          8.0   70      1\n2 46.6         8          455        230   5140         24.8   82      3\n\n# find mean and st dev of each quantitative predictor\n# -&gt; then format nicely\ndata_auto %&gt;% \n  select(where(is.numeric)) %&gt;% \n  summarize(across(1:ncol(.), list(mean = mean, sd = sd))) %&gt;% \n  pivot_longer(everything(),\n               names_to = \"var\",\n               values_to = \"val\") %&gt;% \n  separate_wider_delim(cols = var,\n                       delim = \"_\",\n                       names = c(\"var\", \"fun\")) %&gt;% \n  pivot_wider(names_from = \"fun\",\n              values_from = \"val\")\n\n# A tibble: 8 × 3\n  var             mean      sd\n  &lt;chr&gt;          &lt;dbl&gt;   &lt;dbl&gt;\n1 mpg            23.4    7.81 \n2 cylinders       5.47   1.71 \n3 displacement  194.   105.   \n4 horsepower    104.    38.5  \n5 weight       2978.   849.   \n6 acceleration   15.5    2.76 \n7 year           76.0    3.68 \n8 origin          1.58   0.806\n\n# EDA\n# -&gt; trying to predict mpg\ndata_auto %&gt;% \n  select(where(is.numeric)) %&gt;% \n  pairs\n\n\n\n\n\n\n# useful variables\n# -&gt; all predictors appear to be correlated with the response (some have non-linear relationship), however there are several that are highly correlated among themselves\n\nQuestion 10\n\n# load data\ndata_boston &lt;- ISLR2::Boston\n\n# &lt; ... easy stuff ... &gt;",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical learning</span>"
    ]
  },
  {
    "objectID": "islr-3.html",
    "href": "islr-3.html",
    "title": "\n4  Linear regression\n",
    "section": "",
    "text": "4.1 Notes",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear regression</span>"
    ]
  },
  {
    "objectID": "islr-3.html#notes",
    "href": "islr-3.html#notes",
    "title": "\n4  Linear regression\n",
    "section": "",
    "text": "4.1.1 Simple linear regression\nhttps://coltongearhart.github.io/regression/notes-slr.html\n\n4.1.2 Multiple linear regression\nhttps://coltongearhart.github.io/regression/notes-multiple-regression-1.html and https://coltongearhart.github.io/regression/notes-multiple-regression-2.html\n\n4.1.3 Other considerations in the regression model\nhttps://coltongearhart.github.io/regression/notes-reg-models-quan-and-qual.html\nThings to study more from other text\n\nLeverage\nVIF\n\n4.1.4 Comparison of linear regression with \\(K\\)-nearest neighbors\nAs discussed earlier, non-parametric methods do not explicitly assume a parametric form for \\(f(X)\\), and thereby provide an alternative and more flexible approach for performing regression. Here we consider one of the simplest and best-known non-parametric methods,\\(K\\)-nearest neighbors regression  (KNN regression). The KNN regression method is closely related to the KNN classifier discussed in the previous chapter. Given a value for \\(K\\) and a prediction point \\(x_0\\), KNN regression first identifies the \\(K\\) training observations that are closest to \\(x_0\\), represented by \\(\\cal{N}_0\\). It then estimates \\(f(x_0)\\) using the average of all the training responses in \\(\\cal{N}_0\\). In other words,\n\\[\n\\hat{f}(x_0) = \\frac{1}{K}\\sum_{x_i \\in \\cal{N}_0} y_i\n\\]\n\nWe see that when \\(K = 1\\), the KNN fit perfectly interpolates the training observations, and consequently takes the form of a step function. When \\(K = 9\\), the KNN fit still is a step function, but averaging over nine observations results in much smaller regions of constant prediction, and consequently a smoother fit. In general, the optimal value for K will depend on the bias-variance tradeoff.\nA small value for \\(K\\) provides the most flexible fit, which will have low bias but high variance. This variance is due to the fact that the prediction in a given region is entirely dependent on just one observation. In contrast, larger values of \\(K\\) provide a smoother and less variable fit; the prediction in a region is an average of several points, and so changing one observation has a smaller effect. However, the smoothing may cause bias by masking some of the structure in \\(f(X)\\).\nIn what setting will a parametric approach such as least squares linear regression outperform a non-parametric approach such as KNN regression? The answer is simple: the parametric approach will outperform the non- parametric approach if the parametric form that has been selected is close to the true form of \\(f\\).\n\nFigure 3.17 provides an example with data generated from a one-dimensional linear regression model. The black solid lines represent \\(f(X)\\), while the blue curves correspond to the KNN fits using \\(K = 1\\) and \\(K = 9\\). In this case, the \\(K = 1\\) predictions are far too variable, while the smoother \\(K = 9\\) fit is much closer to \\(f(X)\\). **However, since the true relationship is linear, it is hard for a non-parametric approach to compete with linear regression: a non-parametric approach incurs a cost in variance that is not offset by a reduction in bias.*\n\nFigure 3.19 examines the relative performances of least squares regression and KNN under increasing levels of non-linearity in the relationship between \\(X\\) and \\(Y\\). In more non-linear situation, KNN substantially outperforms linear regression for all values of \\(K\\). Note that as the extent of non-linearity increases, there is little change in the test set MSE for the non-parametric KNN method, but there is a large increase in the test set MSE of linear regression.\nIn a real life situation in which the true relationship is unknown, one might suspect that KNN should be favored over linear regression because it will at worst be slightly inferior to linear regression if the true relationship is linear, and may give substantially better results if the true relationship is non-linear. But in reality, even when the true relationship is highly non-linear, KNN may still provide inferior results to linear regression. But in higher dimensions, KNN often performs worse than linear regression.\n\nFigure 3.20 considers the same strongly non-linear situation as in the second row of Figure 3.19, except that we have added additional noise predictors that are not associated with the response. But for \\(p = 3\\) the results are mixed, and for \\(p \\ge 4\\) linear regression is superior to KNN. In fact, the increase in dimension has only caused a small deterioration in the linear regression test set MSE, but it has caused more than a ten-fold increase in the MSE for KNN. This decrease in performance as the dimension increases is a common problem for KNN, and results from the fact that in higher dimensions there is effectively a reduction in sample size. In this data set there are 50 training observations; when \\(p = 1\\), this provides enough information to accurately estimate \\(f(X)\\). However, spreading 50 observations over \\(p = 20\\) dimensions results in a phenomenon in which a given observation has no nearby neighbors – this is the so-called curse of dimensionality.\nAs a general rule, parametric methods will tend to outperform non-parametric approaches when there is a small number of observations per predictor. Even when the dimension is small, we might prefer linear regression to KNN from an interpretability standpoint. If the test MSE of KNN is only slightly lower than that of linear regression, we might be willing to forego a little bit of prediction accuracy for the sake of a simple model that can be described in terms of just a few coefficients, and for which p-values are available.",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear regression</span>"
    ]
  },
  {
    "objectID": "islr-3.html#lab",
    "href": "islr-3.html#lab",
    "title": "\n4  Linear regression\n",
    "section": "\n4.2 Lab",
    "text": "4.2 Lab\n&lt; just basic regression commands &gt;\nSome key points\n\n\nhatvalues(&lt; mod &gt;): Computes the hat values for each observation.\n\nThen can run hatvalues(&lt; mod &gt;) %&gt;% which.max to get the largest one.\n\n\ncar::vif(): Computes the VIF for each predictor.\n\nIn the formula, poly() by default orthogonalizes the predictors, so they are not simply a sequence of higher powers of the argument.\n\nHowever, a linear model applied to the output of the poly() function will have the same fitted values as a linear model applied to the raw polynomials (raw = TRUE; although the coefficient estimates, standard errors, and p-values will differ).\n\n\ncontrasts(&lt; factor &gt;): Returns the coding that R uses for the dummy variables.",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear regression</span>"
    ]
  },
  {
    "objectID": "islr-3.html#exercises",
    "href": "islr-3.html#exercises",
    "title": "\n4  Linear regression\n",
    "section": "\n4.3 Exercises",
    "text": "4.3 Exercises\n\n4.3.1 Conceptual\nQuestion 1\n\nDescribe the null hypotheses to which the p-values shown below correspond. Explain what conclusions you can draw based on these p-values. Your explanation should be phrased in terms of the predictors, rather than in terms of the coefficients of the linear model.\n\n\n\n# A tibble: 4 × 5\n  term         estimate std.error statistic  p.value\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     1.04     0.271       3.85 1.73e- 4\n2 Petal.Width     0.558    0.123       4.55 1.10e- 5\n3 Petal.Length   -0.586    0.0621     -9.43 8.75e-17\n4 Sepal.Length    0.607    0.0622      9.77 1.20e-17\n\n\nFor Petal.Length:\n\\[\n\\begin{align*}\nH_0&: \\beta_{\\text{Petal.Length}} = 0 \\\\\nH_A&: \\beta_{\\text{Petal.Length}} \\ne 0\n\\end{align*}\n\\]\n\n# fit model\nmod_iris &lt;- lm(Sepal.Width ~ Petal.Width + Petal.Length + Sepal.Length, data = iris, x = TRUE)\n\n# verify p-value\nbeta_hat &lt;- coef(mod_iris)[\"Petal.Length\"]\nX &lt;- mod_iris$x\nse_beta_hats &lt;- summary(mod_iris)$sigma^2 * solve(t(X) %*% (X))\nse_beta_hat &lt;- sqrt(se_beta_hats[3,3])\npt(q = beta_hat / se_beta_hat, df = nobs(mod_iris) - length(coef(mod_iris)), lower.tail = TRUE) * 2 %&gt;% as.numeric\n\n             Petal.Length \n0.00000000000000008753029 \n\n\nQuestion 2\n\nCarefully explain the differences between the KNN classifier and KNN regression methods.\n\nSimply stated, The KNN classifier is categorical and assigns a value based on the most frequent observed category among \\(K\\) nearest neighbors, whereas KNN regression assigns a continuous variable, the average of the response variables for the \\(K\\) nearest neighbors. This represents two different summary functions, which are: for classification\n\\[\n\\hat{f}(x_0) = \\text{max}_j\\bigg\\{\\frac{1}{K}\\sum_{x_i \\in \\cal{N}_0} I(y_i = j)\\bigg\\}\n\\]\nand for regression\n\\[\n\\hat{f}(x_0) = \\frac{1}{K}\\sum_{x_i \\in \\cal{N}_0} y_i\n\\]\nQuestion 3\n\nSuppose we have a data set with five predictors, \\(X_1\\) = GPA, \\(X_2\\) = IQ, \\(X_3\\) = Level (1 for College and 0 for High School), \\(X_4\\) = Interaction between GPA and IQ, and \\(X_5\\) = Interaction between GPA and Level. The response is starting salary after graduation (in thousands of dollars). Suppose we use least squares to fit the model, and get \\(\\hat\\beta_0 = 50\\), \\(\\hat\\beta_1 = 20\\), \\(\\hat\\beta_2 = 0.07\\), \\(\\hat\\beta_3 = 35\\), \\(\\hat\\beta_4 = 0.01\\), \\(\\hat\\beta_5 = -10\\).\n\n\n\nWhich answer is correct, and why?\n\nFor a fixed value of IQ and GPA, high school graduates earn more on average than college graduates.\nFor a fixed value of IQ and GPA, college graduates earn more on average than high school graduates.\nFor a fixed value of IQ and GPA, high school graduates earn more on average than college graduates provided that the GPA is high enough.\nFor a fixed value of IQ and GPA, college graduates earn more on average than high school graduates provided that the GPA is high enough.\n\n\n\n\n\nFalse: \\(\\hat{\\beta}_3 &gt; 0\\)\nFalse: Have to take into account the interactions\nTrue: \\(\\hat{\\beta}_5 = -10\\), which means the slope for GPA decreases by 10 for college students. So for large enough GPAs, high school plane surpasses that of college\nFalse: above reason\n\n\n# fitted response curve\nmodel &lt;- function(gpa, iq, level) {\n  50 +\n  gpa * 20 +\n  iq * 0.07 +\n  level * 35 +\n  gpa * iq * 0.01 +\n  gpa * level * -10\n}\n\n# set predictors\nx &lt;- seq(1, 5, length = 10)\ny &lt;- seq(1, 200, length = 20)\n\n# calculate response\ncollege &lt;- outer(x, y, FUN = model, level = 1) %&gt;% t\nhigh_school &lt;- outer(x, y, FUN = model, level = 0) %&gt;% t\n\n# plot surfaces\nplot_ly(x = x, y = y) %&gt;% \n  add_surface(\n    z = ~college,\n    colorscale = list(c(0, 1), c(\"rgb(107,184,214)\", \"rgb(0,90,124)\")),\n    colorbar = list(title = \"College\")) %&gt;% \n  add_surface(\n    z = ~high_school,\n    colorscale = list(c(0, 1), c(\"rgb(255,112,184)\", \"rgb(128,0,64)\")),\n    colorbar = list(title = \"High school\")) %&gt;% \n  layout(scene = list(\n    xaxis = list(title = \"GPA\"),\n    yaxis = list(title = \"IQ\"),\n    zaxis = list(title = \"Salary\")))\n\nError in layout(., scene = list(xaxis = list(title = \"GPA\"), yaxis = list(title = \"IQ\"), : unused argument (scene = list(xaxis = list(title = \"GPA\"), yaxis = list(title = \"IQ\"), zaxis = list(title = \"Salary\")))\n\n\n\n\nPredict the salary of a college graduate with IQ of 110 and a GPA of 4.0.\n\n\n\nmodel(gpa = 4, iq = 110, level = 1)\n\n[1] 137.1\n\n\n\n\nTrue or false: Since the coefficient for the GPA/IQ interaction term is very small, there is very little evidence of an interaction effect. Justify your answer.\n\n\nFalse. Scale is based on units, need information about the significance.\nQuestion 4\n\nI collect a set of data (\\(n = 100\\) observations) containing a single predictor and a quantitative response. I then fit a linear regression model to the data, as well as a separate cubic regression, i.e. \\(Y = \\beta_0 + \\beta_1 X + \\beta_2 X^2 + \\beta_3 X^3 + \\epsilon\\).\n\n\n\nSuppose that the true relationship between \\(X\\) and \\(Y\\) is linear, i.e. \\(Y = \\beta_0 + \\beta_1X + \\epsilon\\). Consider the training residual sum of squares (RSS) for the linear regression, and also the training RSS for the cubic regression. Would we expect one to be lower than the other, would we expect them to be the same, or is there not enough information to tell? Justify your answer.\n\n\nThe more complex model will have a smaller training RSS because of the lower bias.\n\n\nAnswer (a) using test rather than training RSS.\n\n\nGiven that the true model is actually linear, the more complex model will have a larger testing RSS because of the larger variance (overfitting).\n\n\nSuppose that the true relationship between \\(X\\) and \\(Y\\) is not linear, but we don’t know how far it is from linear. Consider the training RSS for the linear regression, and also the training RSS for the cubic regression. Would we expect one to be lower than the other, would we expect them to be the same, or is there not enough information to tell? Justify your answer.\n\n\nThe further from linear the true model gets, the larger the training RSS will become for the linear model because of low flexibility and high bias.\n\n\nAnswer (c) using test rather than training RSS.\n\n\nSame as (c).\nQuestion 5\n\nConsider the fitted values that result from performing linear regression without an intercept. In this setting, the \\(i\\)th fitted value takes the form \\[\n\\hat{y}_i = x_i\\hat\\beta\n\\] where \\[\n\\hat{\\beta} = \\left(\\sum_{i=1}^nx_iy_i\\right) / \\left(\\sum_{i' = 1}^n x^2_{i'}\\right).\n\\] Show that we can write \\[\n\\hat{y}_i = \\sum_{i' = 1}^na_{i'}y_{i'}\n\\] What is \\(a_{i'}\\)? Note: We interpret this result by saying that the fitted values from linear regression are linear combinations of the response values.\n\n\\[\n\\begin{align}\n\\hat{y}_i\n  & = x_i \\frac{\\sum_{i=1}^nx_iy_i}{\\sum_{i' = 1}^n x^2_{i'}} \\\\\n  & = x_i \\frac{\\sum_{i'=1}^nx_{i'}y_{i'}}{\\sum_{i'' = 1}^n x^2_{i''}} \\\\\n  & = \\frac{\\sum_{i'=1}^n x_i x_{i'}y_{i'}}{\\sum_{i'' = 1}^n x^2_{i''}} \\\\\n  & = \\sum_{i'=1}^n \\frac{ x_i x_{i'}y_{i'}}{\\sum_{i'' = 1}^n x^2_{i''}} \\\\\n  & = \\sum_{i'=1}^n \\frac{ x_i x_{i'}}{\\sum_{i'' = 1}^n x^2_{i''}} y_{i'}\n\\end{align}\n\\]\nQuestion 6\n\nUsing (3.4), argue that in the case of simple linear regression, the least squares line always passes through the point \\((\\bar{x}, \\bar{y})\\).\n\n\\[\n\\begin{align}\n\\hat{y} &= \\hat\\beta_0 + \\hat\\beta_1\\bar{x} \\\\\n  &= (\\bar{y} - \\hat\\beta_1\\bar{x}) + \\hat\\beta_1\\bar{x} \\\\\n  &= \\bar{y}\n\\end{align}\n\\]\nQuestion 7\n\nIt is claimed in the text that in the case of simple linear regression of \\(Y\\) onto \\(X\\), the \\(R^2\\) statistic (3.17) is equal to the square of the correlation between \\(X\\) and \\(Y\\) (3.18). Prove that this is the case. For simplicity, you may assume that \\(\\bar{x} = \\bar{y} = 0\\).\n\n&lt; just algebra after making simplifying assumptions &gt;\n\n4.3.2 Applied\nQuestion 8\n\n# read in data\ndata_car &lt;- ISLR2::Auto\nplot(mpg ~ horsepower, data_car)\n\n# fit model\nmod_car &lt;- lm(mpg ~ horsepower, data_car)\nplot(mpg ~ horsepower, data_car)\nabline(mod_car, col = \"red\")\n\n\n\n\n\n\nglimpse(mod_car)\n\nList of 12\n $ coefficients : Named num [1:2] 39.936 -0.158\n  ..- attr(*, \"names\")= chr [1:2] \"(Intercept)\" \"horsepower\"\n $ residuals    : Named num [1:392] -1.416 1.109 1.741 -0.259 -0.838 ...\n  ..- attr(*, \"names\")= chr [1:392] \"1\" \"2\" \"3\" \"4\" ...\n $ effects      : Named num [1:392] -464.206 120.138 1.745 -0.255 -0.819 ...\n  ..- attr(*, \"names\")= chr [1:392] \"(Intercept)\" \"horsepower\" \"\" \"\" ...\n $ rank         : int 2\n $ fitted.values: Named num [1:392] 19.4 13.9 16.3 16.3 17.8 ...\n  ..- attr(*, \"names\")= chr [1:392] \"1\" \"2\" \"3\" \"4\" ...\n $ assign       : int [1:2] 0 1\n $ qr           :List of 5\n  ..$ qr   : num [1:392, 1:2] -19.799 0.0505 0.0505 0.0505 0.0505 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. ..- attr(*, \"assign\")= int [1:2] 0 1\n  ..$ qraux: num [1:2] 1.05 1.08\n  ..$ pivot: int [1:2] 1 2\n  ..$ tol  : num 0.0000001\n  ..$ rank : int 2\n  ..- attr(*, \"class\")= chr \"qr\"\n $ df.residual  : int 390\n $ xlevels      : Named list()\n $ call         : language lm(formula = mpg ~ horsepower, data = data_car)\n $ terms        :Classes 'terms', 'formula'  language mpg ~ horsepower\n  .. ..- attr(*, \"variables\")= language list(mpg, horsepower)\n  .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. ..- attr(*, \"term.labels\")= chr \"horsepower\"\n  .. ..- attr(*, \"order\")= int 1\n  .. ..- attr(*, \"intercept\")= int 1\n  .. ..- attr(*, \"response\")= int 1\n  .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n  .. ..- attr(*, \"predvars\")= language list(mpg, horsepower)\n  .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. ..- attr(*, \"names\")= chr [1:2] \"mpg\" \"horsepower\"\n $ model        :'data.frame':  392 obs. of  2 variables:\n  ..$ mpg       : num [1:392] 18 15 18 16 17 15 14 14 14 15 ...\n  ..$ horsepower: int [1:392] 130 165 150 150 140 198 220 215 225 190 ...\n  ..- attr(*, \"terms\")=Classes 'terms', 'formula'  language mpg ~ horsepower\n  .. .. ..- attr(*, \"variables\")= language list(mpg, horsepower)\n  .. .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..- attr(*, \"term.labels\")= chr \"horsepower\"\n  .. .. ..- attr(*, \"order\")= int 1\n  .. .. ..- attr(*, \"intercept\")= int 1\n  .. .. ..- attr(*, \"response\")= int 1\n  .. .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n  .. .. ..- attr(*, \"predvars\")= language list(mpg, horsepower)\n  .. .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. .. ..- attr(*, \"names\")= chr [1:2] \"mpg\" \"horsepower\"\n - attr(*, \"class\")= chr \"lm\"\n\n# get strength\nmod_car %&gt;% broom::glance() %&gt;% pull(r.squared)\n\n[1] 0.6059483\n\n# get coef\nbroom::tidy(mod_car)\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic   p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)   39.9     0.717        55.7 1.22e-187\n2 horsepower    -0.158   0.00645     -24.5 7.03e- 81\n\n# inference\n# -&gt; prediction of new obs\npredict(mod_car, newdata = data.frame(horsepower = c(98)), interval = \"pred\")\n\n       fit     lwr      upr\n1 24.46708 14.8094 34.12476\n\npredict(mod_car, newdata = data.frame(horsepower = c(98)), interval = \"conf\")\n\n       fit      lwr      upr\n1 24.46708 23.97308 24.96108\n\n# diagnostic plots\nplot(mod_car, which = 1:2)\n\n\n\n\n\n\n\n\n\n\n\n\n# -&gt; nonlinearity and unequal variance\n\nQuestion 9\n\n# scatterplot matrix\npairs(data_car)\n\n\n\n\n\n\n# correlation matrix\ncor(data_car[, 1:8])\n\n                    mpg  cylinders displacement horsepower     weight\nmpg           1.0000000 -0.7776175   -0.8051269 -0.7784268 -0.8322442\ncylinders    -0.7776175  1.0000000    0.9508233  0.8429834  0.8975273\ndisplacement -0.8051269  0.9508233    1.0000000  0.8972570  0.9329944\nhorsepower   -0.7784268  0.8429834    0.8972570  1.0000000  0.8645377\nweight       -0.8322442  0.8975273    0.9329944  0.8645377  1.0000000\nacceleration  0.4233285 -0.5046834   -0.5438005 -0.6891955 -0.4168392\nyear          0.5805410 -0.3456474   -0.3698552 -0.4163615 -0.3091199\norigin        0.5652088 -0.5689316   -0.6145351 -0.4551715 -0.5850054\n             acceleration       year     origin\nmpg             0.4233285  0.5805410  0.5652088\ncylinders      -0.5046834 -0.3456474 -0.5689316\ndisplacement   -0.5438005 -0.3698552 -0.6145351\nhorsepower     -0.6891955 -0.4163615 -0.4551715\nweight         -0.4168392 -0.3091199 -0.5850054\nacceleration    1.0000000  0.2903161  0.2127458\nyear            0.2903161  1.0000000  0.1815277\norigin          0.2127458  0.1815277  1.0000000\n\n# fit model\nmod_car_mlr &lt;- lm(mpg ~ . - name, data = data_car, x = TRUE)\nsummary(mod_car_mlr)\n\n\nCall:\nlm(formula = mpg ~ . - name, data = data_car, x = TRUE)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-9.5903 -2.1565 -0.1169  1.8690 13.0604 \n\nCoefficients:\n               Estimate Std. Error t value             Pr(&gt;|t|)    \n(Intercept)  -17.218435   4.644294  -3.707              0.00024 ***\ncylinders     -0.493376   0.323282  -1.526              0.12780    \ndisplacement   0.019896   0.007515   2.647              0.00844 ** \nhorsepower    -0.016951   0.013787  -1.230              0.21963    \nweight        -0.006474   0.000652  -9.929 &lt; 0.0000000000000002 ***\nacceleration   0.080576   0.098845   0.815              0.41548    \nyear           0.750773   0.050973  14.729 &lt; 0.0000000000000002 ***\norigin         1.426141   0.278136   5.127          0.000000467 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.328 on 384 degrees of freedom\nMultiple R-squared:  0.8215,    Adjusted R-squared:  0.8182 \nF-statistic: 252.4 on 7 and 384 DF,  p-value: &lt; 0.00000000000000022\n\n# is a relationship between Y and the set of Xs\n# -&gt; displacement, weight, year and origin appear to be significant predictors\n# -&gt; hat(beta)_year &gt;  0 ==&gt; newer cars get better gas mileage\n\n# diagnostic plots\nplot(mod_car_mlr, which = 1:2)\n\n\n\n\n\n\n\n\n\n\n\n\n# -&gt; unequal variance\n\n# search for higher order effects\n\n# get residuals\ne &lt;- residuals(mod_car_mlr) \n\n# plot against each X\nnms_x &lt;- colnames(mod_car_mlr$x[, -1])\nmap2(data.frame(mod_car_mlr$x)[, -1], nms_x, function(x, nm) {\n  plot(x = x, y = e, main = nm)\n  lines(lowess(x = x, y = e), col = \"red\")\n  abline(h = 0, col = \"grey\")\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n$cylinders\nNULL\n\n$displacement\nNULL\n\n$horsepower\nNULL\n\n$weight\nNULL\n\n$acceleration\nNULL\n\n$year\nNULL\n\n$origin\nNULL\n\n# if there is relationship of any kind, that indicates there is something more going on because we have controlled for the linear main effects\n# -&gt; something with displacement, horsepower, weight, and, year\n# -&gt; combined with the hereditary principle, these seem like good variables\n\n# try interaction effects\nmod_car_int &lt;- update(mod_car_mlr, . ~ . + displacement:weight + displacement:year + displacement:origin + weight:year + weight:origin + year:origin, x = TRUE)\nsummary(mod_car_int)\n\n\nCall:\nlm(formula = mpg ~ cylinders + displacement + horsepower + weight + \n    acceleration + year + origin + displacement:weight + displacement:year + \n    displacement:origin + weight:year + weight:origin + year:origin, \n    data = data_car, x = TRUE)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-7.717 -1.608 -0.033  1.301 13.031 \n\nCoefficients:\n                         Estimate    Std. Error t value           Pr(&gt;|t|)    \n(Intercept)         -41.805566419  24.906721073  -1.678           0.094079 .  \ncylinders             0.452489261   0.304470575   1.486           0.138073    \ndisplacement          0.080930869   0.082684765   0.979           0.328311    \nhorsepower           -0.044418845   0.012621585  -3.519           0.000485 ***\nweight               -0.006558690   0.011117698  -0.590           0.555588    \nacceleration          0.113084940   0.086916781   1.301           0.194027    \nyear                  1.279561152   0.323065989   3.961 0.0000893223144297 ***\norigin               -1.670022247   5.242728051  -0.319           0.750251    \ndisplacement:weight   0.000022021   0.000002833   7.772 0.0000000000000736 ***\ndisplacement:year    -0.002170403   0.001144312  -1.897           0.058631 .  \ndisplacement:origin   0.011891682   0.012453639   0.955           0.340251    \nweight:year          -0.000055344   0.000150271  -0.368           0.712861    \nweight:origin         0.000206268   0.000967806   0.213           0.831340    \nyear:origin           0.004978089   0.066417438   0.075           0.940293    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.856 on 378 degrees of freedom\nMultiple R-squared:  0.8705,    Adjusted R-squared:  0.8661 \nF-statistic: 195.5 on 13 and 378 DF,  p-value: &lt; 0.00000000000000022\n\n# only a couple of the interactions are significant\n\nplot(mod_car_int, which = 1:2)\n\n\n\n\n\n\n\n\n\n\n\n\n# get residuals\ne &lt;- residuals(mod_car_int) \n\n# plot against each X\nnms_x &lt;- colnames(mod_car_int$x[, -1])\nmap2(data.frame(mod_car_int$x)[, -1], nms_x, function(x, nm) {\n  plot(x = x, y = e, main = nm)\n  lines(lowess(x = x, y = e), col = \"red\")\n  abline(h = 0, col = \"grey\")\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n$cylinders\nNULL\n\n$displacement\nNULL\n\n$horsepower\nNULL\n\n$weight\nNULL\n\n$acceleration\nNULL\n\n$year\nNULL\n\n$origin\nNULL\n\n$displacement.weight\nNULL\n\n$displacement.year\nNULL\n\n$displacement.origin\nNULL\n\n$weight.year\nNULL\n\n$weight.origin\nNULL\n\n$year.origin\nNULL\n\n# now only unequal variance is left after controlling for interactions as well\n# -&gt; except for maybe year\n# -&gt; every function of year is significant\nmod_car_int2 &lt;- update(mod_car_int, . ~ . + sqrt(year), data = data_car)\n\n# see if significant\nanova(mod_car_int2, mod_car_int)\n\nAnalysis of Variance Table\n\nModel 1: mpg ~ cylinders + displacement + horsepower + weight + acceleration + \n    year + origin + sqrt(year) + displacement:weight + displacement:year + \n    displacement:origin + weight:year + weight:origin + year:origin\nModel 2: mpg ~ cylinders + displacement + horsepower + weight + acceleration + \n    year + origin + displacement:weight + displacement:year + \n    displacement:origin + weight:year + weight:origin + year:origin\n  Res.Df    RSS Df Sum of Sq     F     Pr(&gt;F)    \n1    377 2927.9                                  \n2    378 3083.5 -1   -155.63 20.04 0.00001006 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nQuestion 10\n\n# read in data\n# -&gt; price = quan, urban and us = qual\ndata_seats &lt;- ISLR2::Carseats\n\n# fit mlr model\nmod_seats &lt;- lm(Sales ~ Price + Urban + US, data = data_seats, x = TRUE)\nmod_seats %&gt;% broom::tidy()\n\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)  13.0      0.651     20.0    3.63e-62\n2 Price        -0.0545   0.00524  -10.4    1.61e-22\n3 UrbanYes     -0.0219   0.272     -0.0807 9.36e- 1\n4 USYes         1.20     0.259      4.63   4.86e- 6\n\n\nCoefficient interpretations\n\\(\\hat{\\beta}_0\\) = 13.043: For a non-urban store located outside of the US, we expect there to be 13,043 car seat sales on average.\n\\(\\hat{\\beta}_{\\text{Price}}\\) = -0.054: For each dollar increase in the price of the carseat, we expect the unit sales to decrease by approximately 54 units, on average.\n\\(\\hat{\\beta}_{\\text{UrbanYes}}\\) = -0.022: Stores located in urban areas have approximately 22 less sales on average than non-urban stores.\n\\(\\hat{\\beta}_{\\text{USYes}}\\) = 1.201: US stores have approximately 1201 more sales on average than non-US stores.\nWritten-out model\n\\[\n\\text{Sales} = \\Bigg(\\hat{\\beta}_0 + \\begin{cases}\n   \\hat{\\beta}_{\\text{UrbanYes}},     & \\text{if $\\text{Urban}$ = Yes, $\\text{US}$ = No} \\\\\n    \\hat{\\beta}_{\\text{USYes}},    & \\text{if $\\text{Urban}$ = No, $\\text{US}$ = Yes} \\\\\n    \\hat{\\beta}_{\\text{UrbanYes}} + \\hat{\\beta}_{\\text{USYes}},    & \\text{if $\\text{Urban}$ = $\\text{US}$ = Yes} \\\\\n    0,       & \\text{Otherwise}\n\\end{cases}\\Bigg)\n+ \\hat{\\beta}_{\\text{Price}} \\times \\text{Price}\n\\]\nwhich come out to be\n\\[\n\\text{Sales} = \\Bigg(13 + \\begin{cases}\n   -0.022,   & \\text{if $\\text{Urban}$ is Yes, $\\text{US}$ is No} \\\\\n    1.20,    & \\text{if $\\text{Urban}$ is No, $\\text{US}$ is Yes} \\\\\n    1.18,    & \\text{if $\\text{Urban}$ and $\\text{US}$ is Yes} \\\\\n    0,       & \\text{Otherwise}\n\\end{cases}\n\\Bigg)\n- 0.054 \\times \\textit{Price}\n\\]\n\n# reject null for Price and US (not for Urban)\n\n# fit smaller model and test\nmod_seats2 &lt;- update(mod_seats, . ~ . - Urban)\nanova(mod_seats, mod_seats2)\n\nAnalysis of Variance Table\n\nModel 1: Sales ~ Price + Urban + US\nModel 2: Sales ~ Price + US\n  Res.Df    RSS Df Sum of Sq      F Pr(&gt;F)\n1    396 2420.8                           \n2    397 2420.9 -1  -0.03979 0.0065 0.9357\n\n# -&gt; fail to reject --&gt; reduced model is better\n\nmod_seats %&gt;% broom::glance() %&gt;% pull(r.squared)\n\n[1] 0.2392754\n\nmod_seats2 %&gt;% broom::glance() %&gt;% pull(r.squared)\n\n[1] 0.2392629\n\n# -&gt; just about the same fit\n\n# 95% confidence intervals for coefficients on reduced model\nconfint(mod_seats2)\n\n                  2.5 %      97.5 %\n(Intercept) 11.79032020 14.27126531\nPrice       -0.06475984 -0.04419543\nUSYes        0.69151957  1.70776632\n\n# inspect for outliers / high leverage observations\nplot(mod_seats2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# -&gt; there are a few high leverage points, but they are not influential\n\nQuestion 11\n\n# generate data\nset.seed(1)\nx &lt;- rnorm(100)\ny &lt;- 2 * x + rnorm(100)\n\n# fit models without intercept\nmod_yx &lt;- lm(y ~ x + 0)\nsummary(mod_yx)\n\n\nCall:\nlm(formula = y ~ x + 0)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.9154 -0.6472 -0.1771  0.5056  2.3109 \n\nCoefficients:\n  Estimate Std. Error t value            Pr(&gt;|t|)    \nx   1.9939     0.1065   18.73 &lt;0.0000000000000002 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.9586 on 99 degrees of freedom\nMultiple R-squared:  0.7798,    Adjusted R-squared:  0.7776 \nF-statistic: 350.7 on 1 and 99 DF,  p-value: &lt; 0.00000000000000022\n\nmod_xy &lt;- lm(x ~ y + 0)\nsummary(mod_xy)\n\n\nCall:\nlm(formula = x ~ y + 0)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-0.8699 -0.2368  0.1030  0.2858  0.8938 \n\nCoefficients:\n  Estimate Std. Error t value            Pr(&gt;|t|)    \ny  0.39111    0.02089   18.73 &lt;0.0000000000000002 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4246 on 99 degrees of freedom\nMultiple R-squared:  0.7798,    Adjusted R-squared:  0.7776 \nF-statistic: 350.7 on 1 and 99 DF,  p-value: &lt; 0.00000000000000022\n\n# results\n# -&gt; different estimates, same test-statistics\n# -&gt; this can be shown mathematically using the derived formulas for regression without an intercept\n\n# now with an intercept, show test statistics are the same for y ~ x and x ~ y\nmod_yx &lt;- lm(y ~ x)\nmod_yx %&gt;% broom::glance()\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic  p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     0.778         0.776 0.963      344. 7.72e-34     1  -137.  280.  288.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\nmod_xy &lt;- lm(x ~ y)\nmod_xy %&gt;% broom::glance()\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic  p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     0.778         0.776 0.425      344. 7.72e-34     1  -55.3  117.  124.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\n\nQuestion 12\nCan show that estimates will be the same if swap \\(X\\) and \\(Y\\) variables under a certain condition.\n\\[\nY \\sim X: \\hat\\beta = \\sum_i x_iy_i / \\sum_{i'} x_{i'}^2\n\\]\nThe coefficient for the regression of X onto Y swaps the \\(x\\) and \\(y\\) variables:\n\\[\nX \\sim Y: \\hat\\beta = \\sum_i x_iy_i / \\sum_{i'} y_{i'}^2\n\\]\nSo they are the same when \\(\\sum_{i} x_{i}^2 = \\sum_{i} y_{i}^2\\)\nQuestion 13\n\n# investigate coefficient confidence intervals based on the amount of noise\nset.seed(1)\nx &lt;- rnorm(100)\nbeta0 &lt;- -1\nbeta1 &lt;- 0.5\n\n# generate three response vecotrs with difference error variances\ny &lt;- c(0.5, 0.1, 1) %&gt;% map(\\(epsilon) beta0 + beta1 * x + rnorm(100, 0, epsilon))\nnames(y) &lt;- c(\"original epsilon\", \"smaller epsilon\", \"larger epsilon\")\n\n# fit models based on same x\nmods &lt;- y %&gt;% map(\\(y) lm(y ~ x))\n\n# calculate coefficient confidence intervals\nmods %&gt;% map(\\(mod) coef(mod)[2])\n\n$`original epsilon`\n        x \n0.4994698 \n\n$`smaller epsilon`\n        x \n0.5021167 \n\n$`larger epsilon`\n        x \n0.4443139 \n\nmods %&gt;% map(\\(mod) confint(mod))\n\n$`original epsilon`\n                 2.5 %     97.5 %\n(Intercept) -1.1150804 -0.9226122\nx            0.3925794  0.6063602\n\n$`smaller epsilon`\n                 2.5 %     97.5 %\n(Intercept) -1.0180413 -0.9764850\nx            0.4790377  0.5251957\n\n$`larger epsilon`\n                 2.5 %     97.5 %\n(Intercept) -1.1413399 -0.7433293\nx            0.2232721  0.6653558\n\n# wider confidence intervals with more noise as expected, and more biased fits\n\nQuestion 14\n\n# generate data\nset.seed(1)\nx1 &lt;- runif(100)\nx2 &lt;- 0.5 * x1 + rnorm(100) / 10\ny &lt;- 2 + 2 * x1 + 0.3 * x2 + rnorm(100)\n\nThe model is of the form:\n\\[\nY = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + \\epsilon\n\\]\nThe coefficients are \\(\\beta_0 = 2\\), \\(\\beta_1 = 2\\), \\(\\beta_3 = 0.3\\).\n\n# investigate relationship between x1 and x2\ncor(x1, x2)\n\n[1] 0.8351212\n\nplot(x1, x2)\n\n\n\n\n\n\n# fit model\nmod &lt;- lm(y ~ x1 + x2)\n\n# compare fitted coefficients to population values, then test\ncoef(mod)\n\n(Intercept)          x1          x2 \n   2.130500    1.439555    1.009674 \n\nmod %&gt;% broom::tidy()\n\n# A tibble: 3 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     2.13     0.232     9.19  7.61e-15\n2 x1              1.44     0.721     2.00  4.87e- 2\n3 x2              1.01     1.13      0.891 3.75e- 1\n\n# fail to reject for x2\n\n# now fit models with the predictors individually\nmod1 &lt;- lm(y ~ x1)\nmod2 &lt;- lm(y ~ x2)\nmod1 %&gt;% broom::tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     2.11     0.231      9.15 8.27e-15\n2 x1              1.98     0.396      4.99 2.66e- 6\n\nmod2 %&gt;% broom::tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     2.39     0.195     12.3  1.68e-21\n2 x2              2.90     0.633      4.58 1.37e- 5\n\n# both reject\n# -&gt; this contradicts the mlr model where x2 was not significant\n\n# obtain new observations\nx1 &lt;- c(x1, 0.1)\nx2 &lt;- c(x2, 0.8)\ny &lt;- c(y, 6)\n\n# refit models and see effect\nmod_new &lt;- lm(y ~ x1 + x2)\nmod1_new &lt;- lm(y ~ x1)\nmod2_new &lt;- lm(y ~ x2)\nmod_new %&gt;% broom::tidy()\n\n# A tibble: 3 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)    2.23      0.231     9.62  7.91e-16\n2 x1             0.539     0.592     0.911 3.65e- 1\n3 x2             2.51      0.898     2.80  6.14e- 3\n\nmod1_new %&gt;% broom::tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     2.26     0.239      9.44 1.78e-15\n2 x1              1.77     0.412      4.28 4.29e- 5\n\nmod2_new %&gt;% broom::tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     2.35     0.191     12.3  1.40e-21\n2 x2              3.12     0.604      5.16 1.25e- 6\n\n# seems similar results in the individual predictor models, however in the mlr model now both are significant -&gt; investigate why\nplot(mod_new) # high leverage with respect to x1 and x2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(y ~ x1)\npoints(0.1, 6, col = \"red\") # outlier in y\n\n\n\n\n\n\nplot(y ~ x2)\npoints(0.8, 6, col = \"red\") # high leverage (i.e. outlier in x)\n\n\n\n\n\n\n# useful to consider plot of the xs\nplot(x1, x2)\npoints(0.1, 0.8, col = \"red\")\n\n\n\n\n\n\n\nQuestion 15\n\n# read in data\ndata_boston &lt;- ISLR2::Boston\n\n# fit many SLR models\nmods &lt;- data_boston %&gt;% \n  select(-crim) %&gt;% \n  map(\\(x) lm(data_boston$crim ~ x))\nmods %&gt;% map(\\(mod) broom::glance(mod)[1,4:5])\n\n$zn\n# A tibble: 1 × 2\n  statistic    p.value\n      &lt;dbl&gt;      &lt;dbl&gt;\n1      21.1 0.00000551\n\n$indus\n# A tibble: 1 × 2\n  statistic  p.value\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      99.8 1.45e-21\n\n$chas\n# A tibble: 1 × 2\n  statistic p.value\n      &lt;dbl&gt;   &lt;dbl&gt;\n1      1.58   0.209\n\n$nox\n# A tibble: 1 × 2\n  statistic  p.value\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      109. 3.75e-23\n\n$rm\n# A tibble: 1 × 2\n  statistic     p.value\n      &lt;dbl&gt;       &lt;dbl&gt;\n1      25.5 0.000000635\n\n$age\n# A tibble: 1 × 2\n  statistic  p.value\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      71.6 2.85e-16\n\n$dis\n# A tibble: 1 × 2\n  statistic  p.value\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      84.9 8.52e-19\n\n$rad\n# A tibble: 1 × 2\n  statistic  p.value\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      324. 2.69e-56\n\n$tax\n# A tibble: 1 × 2\n  statistic  p.value\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      259. 2.36e-47\n\n$ptratio\n# A tibble: 1 × 2\n  statistic  p.value\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      46.3 2.94e-11\n\n$lstat\n# A tibble: 1 × 2\n  statistic  p.value\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      132. 2.65e-27\n\n$medv\n# A tibble: 1 × 2\n  statistic  p.value\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      89.5 1.17e-19\n\n# -&gt; all significant except chas\n\n# fit mlr model\nmod_mlr &lt;- lm( crim ~ ., data = data_boston)\nsummary(mod_mlr)\n\n\nCall:\nlm(formula = crim ~ ., data = data_boston)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-8.534 -2.248 -0.348  1.087 73.923 \n\nCoefficients:\n              Estimate Std. Error t value         Pr(&gt;|t|)    \n(Intercept) 13.7783938  7.0818258   1.946         0.052271 .  \nzn           0.0457100  0.0187903   2.433         0.015344 *  \nindus       -0.0583501  0.0836351  -0.698         0.485709    \nchas        -0.8253776  1.1833963  -0.697         0.485841    \nnox         -9.9575865  5.2898242  -1.882         0.060370 .  \nrm           0.6289107  0.6070924   1.036         0.300738    \nage         -0.0008483  0.0179482  -0.047         0.962323    \ndis         -1.0122467  0.2824676  -3.584         0.000373 ***\nrad          0.6124653  0.0875358   6.997 0.00000000000859 ***\ntax         -0.0037756  0.0051723  -0.730         0.465757    \nptratio     -0.3040728  0.1863598  -1.632         0.103393    \nlstat        0.1388006  0.0757213   1.833         0.067398 .  \nmedv        -0.2200564  0.0598240  -3.678         0.000261 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.46 on 493 degrees of freedom\nMultiple R-squared:  0.4493,    Adjusted R-squared:  0.4359 \nF-statistic: 33.52 on 12 and 493 DF,  p-value: &lt; 0.00000000000000022\n\n# -&gt; can now only reject for zn, nox, dis, rad, lstat and medv\n\n# extract two sets of coefficients and plot against each other\nbetas_slr &lt;- mods %&gt;% map_dbl(\\(mod) broom::tidy(mod)[2,2] %&gt;% as.numeric)\nbetas_mlr &lt;- coef(mod_mlr)[-1]\nplot(betas_mlr ~ betas_slr)\n\n\n\n\n\n\n\nThe estimated coefficients differ (in particular the estimated coefficient for nox is dramatically different) between the two modelling strategies.\n\n# fit many cubic models models\nmods_cubic &lt;- data_boston %&gt;% \n  select(-c(crim, chas)) %&gt;% \n  map(\\(x) lm(data_boston$crim ~ poly(x, 3)))\nmods_cubic %&gt;% map(\\(mod) broom::tidy(mod))\n\n$zn\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.372      9.71 1.55e-20\n2 poly(x, 3)1   -38.7      8.37      -4.63 4.70e- 6\n3 poly(x, 3)2    23.9      8.37       2.86 4.42e- 3\n4 poly(x, 3)3   -10.1      8.37      -1.20 2.30e- 1\n\n$indus\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.330     11.0  3.61e-25\n2 poly(x, 3)1    78.6      7.42      10.6  8.85e-24\n3 poly(x, 3)2   -24.4      7.42      -3.29 1.09e- 3\n4 poly(x, 3)3   -54.1      7.42      -7.29 1.20e-12\n\n$nox\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.322     11.2  2.74e-26\n2 poly(x, 3)1    81.4      7.23      11.2  2.46e-26\n3 poly(x, 3)2   -28.8      7.23      -3.99 7.74e- 5\n4 poly(x, 3)3   -60.4      7.23      -8.34 6.96e-16\n\n$rm\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.370     9.76  1.03e-20\n2 poly(x, 3)1   -42.4      8.33     -5.09  5.13e- 7\n3 poly(x, 3)2    26.6      8.33      3.19  1.51e- 3\n4 poly(x, 3)3    -5.51     8.33     -0.662 5.09e- 1\n\n$age\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.349     10.4  5.92e-23\n2 poly(x, 3)1    68.2      7.84       8.70 4.88e-17\n3 poly(x, 3)2    37.5      7.84       4.78 2.29e- 6\n4 poly(x, 3)3    21.4      7.84       2.72 6.68e- 3\n\n$dis\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.326     11.1  1.06e-25\n2 poly(x, 3)1   -73.4      7.33     -10.0  1.25e-21\n3 poly(x, 3)2    56.4      7.33       7.69 7.87e-14\n4 poly(x, 3)3   -42.6      7.33      -5.81 1.09e- 8\n\n$rad\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.297    12.2   5.15e-30\n2 poly(x, 3)1   121.       6.68     18.1   1.05e-56\n3 poly(x, 3)2    17.5      6.68      2.62  9.12e- 3\n4 poly(x, 3)3     4.70     6.68      0.703 4.82e- 1\n\n$tax\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.305     11.9  8.96e-29\n2 poly(x, 3)1   113.       6.85      16.4  6.98e-49\n3 poly(x, 3)2    32.1      6.85       4.68 3.67e- 6\n4 poly(x, 3)3    -8.00     6.85      -1.17 2.44e- 1\n\n$ptratio\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.361     10.0  1.27e-21\n2 poly(x, 3)1    56.0      8.12       6.90 1.57e-11\n3 poly(x, 3)2    24.8      8.12       3.05 2.41e- 3\n4 poly(x, 3)3   -22.3      8.12      -2.74 6.30e- 3\n\n$lstat\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.339     10.7  4.94e-24\n2 poly(x, 3)1    88.1      7.63      11.5  1.68e-27\n3 poly(x, 3)2    15.9      7.63       2.08 3.78e- 2\n4 poly(x, 3)3   -11.6      7.63      -1.52 1.30e- 1\n\n$medv\n# A tibble: 4 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     3.61     0.292     12.4  7.02e-31\n2 poly(x, 3)1   -75.1      6.57     -11.4  4.93e-27\n3 poly(x, 3)2    88.1      6.57      13.4  2.93e-35\n4 poly(x, 3)3   -48.0      6.57      -7.31 1.05e-12\n\n\nSeveral models have a significant cubic term, if not then the quadratic term is significant for the rest.",
    "crumbs": [
      "Extended Linear Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear regression</span>"
    ]
  }
]